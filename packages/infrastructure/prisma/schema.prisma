// Prisma schema for Dykstra Funeral Home Family Portal
// Provider: PostgreSQL
// ORM: Prisma

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
}

// Funeral Home (Multi-tenant support)
model FuneralHome {
  id        String   @id @default(cuid())
  name      String
  address   String?
  city      String?
  state     String?
  zip       String?
  phone     String?
  email     String?
  website   String?
  settings  Json?    @default("{}")
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  cases                   Case[]
  users                   User[]
  productCatalog          ProductCatalog[]
  serviceCatalog          ServiceCatalog[]
  contractTemplates       ContractTemplate[]
  leads                   Lead[]
  contacts                Contact[]
  campaigns               Campaign[]
  interactions            Interaction[]
  referralSources         ReferralSource[]
  familyRelationships     FamilyRelationship[]
  emails                  Email[]
  calendarEvents          CalendarEvent[]
  phoneCalls              PhoneCall[]
  prePlanningAppointments PrePlanningAppointment[]
  driverAssignments       DriverAssignment[]
  vehicles                Vehicle[]

  @@map("funeral_homes")
}

// Users (family members, staff, admins)
model User {
  id            String    @id @default(cuid())
  funeralHomeId String?
  email         String    @unique
  name          String
  phone         String?
  role          UserRole
  passwordHash  String? // Nullable for magic link auth
  emailVerified DateTime?
  preferences   Json?     @default("{}") // Notification preferences and other user settings
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  funeralHome       FuneralHome?       @relation(fields: [funeralHomeId], references: [id])
  caseMemberships   CaseMember[]
  createdCases      Case[]             @relation("CreatedCases")
  createdContracts  Contract[]
  signatures        Signature[]
  payments          Payment[]
  uploadedPhotos    Photo[]
  uploadedVideos    Video[]
  createdTasks      Task[]             @relation("CreatedTasks")
  assignedTasks     Task[]             @relation("AssignedTasks")
  auditLogs         AuditLog[]
  internalNotes     InternalNote[]
  sentInvitations   FamilyInvitation[]
  contractTemplates ContractTemplate[]
  assignedLeads     Lead[]             @relation("AssignedLeads")
  staffInteractions Interaction[]      @relation("StaffInteractions")
  oauthTokens       OAuthToken[]
  calendarEvents    CalendarEvent[]    @relation("CalendarEventCreator")
  phoneCalls        PhoneCall[]        @relation("PhoneCallStaff")

  @@index([email])
  @@index([funeralHomeId])
  @@map("users")
}

enum UserRole {
  FAMILY_PRIMARY
  FAMILY_MEMBER
  STAFF // Staff member (read-only access to cases)
  DIRECTOR // Funeral director (full case management)
  ADMIN // System administrator (full access)
  FUNERAL_DIRECTOR // Deprecated: use DIRECTOR instead
}

// Case (funeral case / arrangement)
// SCD Type 2: Tracks complete history of case changes for audit/legal compliance
model Case {
  id          String    @id @default(cuid()) // Row ID (technical key)
  businessKey String // Immutable business identifier
  version     Int       @default(1) // Version number (increments on each change)
  validFrom   DateTime  @default(now()) // When this version became effective
  validTo     DateTime? // When this version was superseded (null = current)
  isCurrent   Boolean   @default(true) // Fast lookup for current version

  funeralHomeId       String
  decedentName        String
  decedentDateOfBirth DateTime?
  decedentDateOfDeath DateTime?
  type                CaseType
  status              CaseStatus
  serviceType         ServiceType?
  serviceDate         DateTime?
  arrangements        Json?        @default("{}")
  createdAt           DateTime     @default(now()) // When this case was originally created
  updatedAt           DateTime     @updatedAt // When this version was created
  createdBy           String

  funeralHome       FuneralHome        @relation(fields: [funeralHomeId], references: [id])
  creator           User               @relation("CreatedCases", fields: [createdBy], references: [id])
  members           CaseMember[]
  contracts         Contract[]
  payments          Payment[]
  memorials         Memorial[]
  documents         Document[]
  tasks             Task[]
  internalNotes     InternalNote[]
  familyInvitations FamilyInvitation[]
  convertedFromLead Lead[]             @relation("ConvertedFromLead")
  interactions      Interaction[]
  emails            Email[]
  calendarEvents    CalendarEvent[]
  phoneCalls        PhoneCall[]

  @@unique([businessKey, version])
  @@index([businessKey, isCurrent]) // Fast current version lookup
  @@index([validFrom, validTo]) // Temporal queries
  @@index([funeralHomeId])
  @@index([status])
  @@index([serviceDate])
  @@map("cases")
}

enum CaseType {
  AT_NEED
  PRE_NEED
  INQUIRY
}

enum CaseStatus {
  INQUIRY
  ACTIVE
  COMPLETED
  ARCHIVED
}

enum ServiceType {
  TRADITIONAL_BURIAL
  TRADITIONAL_CREMATION
  MEMORIAL_SERVICE
  DIRECT_BURIAL
  DIRECT_CREMATION
  CELEBRATION_OF_LIFE
}

// Case members (family members associated with a case)
model CaseMember {
  id          String         @id @default(cuid())
  caseId      String
  userId      String
  role        CaseMemberRole
  permissions Json           @default("{}")
  invitedAt   DateTime       @default(now())
  acceptedAt  DateTime?

  case Case @relation(fields: [caseId], references: [id], onDelete: Cascade)
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([caseId, userId])
  @@index([caseId])
  @@index([userId])
  @@map("case_members")
}

enum CaseMemberRole {
  PRIMARY_CONTACT
  FAMILY_MEMBER
}

// Contract
// SCD Type 2: Immutable once signed - critical for legal compliance and ESIGN Act
model Contract {
  id              String    @id @default(cuid()) // Row ID (technical key)
  businessKey     String // Immutable business identifier
  temporalVersion Int       @default(1) // SCD2 version (renamed from version)
  validFrom       DateTime  @default(now()) // When this version became effective
  validTo         DateTime? // When this version was superseded (null = current)
  isCurrent       Boolean   @default(true) // Fast lookup for current version

  caseId             String
  contractVersion    Int            @default(1) // Business version (e.g. v1.0, v2.0)
  status             ContractStatus
  services           Json           @default("[]")
  products           Json           @default("[]")
  subtotal           Decimal        @db.Decimal(10, 2)
  tax                Decimal        @default(0) @db.Decimal(10, 2)
  totalAmount        Decimal        @db.Decimal(10, 2)
  termsAndConditions String         @db.Text
  createdAt          DateTime       @default(now()) // When this contract was originally created
  updatedAt          DateTime       @updatedAt // When this version was created
  createdBy          String

  case       Case        @relation(fields: [caseId], references: [id], onDelete: Cascade)
  creator    User        @relation(fields: [createdBy], references: [id])
  signatures Signature[]

  @@unique([businessKey, temporalVersion]) // Each temporal version is unique
  @@index([businessKey, isCurrent]) // Fast current version lookup
  @@index([validFrom, validTo]) // Temporal queries
  @@index([caseId])
  @@index([status])
  @@map("contracts")
}

enum ContractStatus {
  DRAFT
  PENDING_REVIEW
  PENDING_SIGNATURES
  FULLY_SIGNED
  CANCELLED
}

// Signature (ESIGN Act compliant)
// SCD Type 2: Signatures are immutable by law - must never be modified or deleted
model Signature {
  id          String    @id @default(cuid()) // Row ID (technical key)
  businessKey String // Immutable business identifier
  version     Int       @default(1) // Version number (should always be 1 for signatures)
  validFrom   DateTime  @default(now()) // When signature was created
  validTo     DateTime? // Should always be null (signatures never expire)
  isCurrent   Boolean   @default(true) // Should always be true (signatures immutable)

  contractId      String
  signerId        String
  signerName      String
  signerEmail     String
  signedAt        DateTime @default(now()) // Legal timestamp of signature
  ipAddress       String // ESIGN Act requirement
  userAgent       String   @db.Text // ESIGN Act requirement
  signatureData   String   @db.Text // Base64 signature image (immutable)
  consentText     String   @db.Text // Exact consent text shown to signer
  consentAccepted Boolean  @default(false) // ESIGN Act requirement

  contract Contract @relation(fields: [contractId], references: [id], onDelete: Cascade)
  signer   User     @relation(fields: [signerId], references: [id])

  @@unique([businessKey, version]) // Enforce single version
  @@index([businessKey, isCurrent]) // Fast lookup
  @@index([validFrom]) // Temporal queries
  @@index([contractId])
  @@index([signerId])
  @@map("signatures")
}

// Payment
// SCD Type 2: Payment history must be immutable for accounting/audit compliance
model Payment {
  id          String    @id @default(cuid()) // Row ID (technical key)
  businessKey String // Immutable business identifier
  version     Int       @default(1) // Version number (tracks status changes)
  validFrom   DateTime  @default(now()) // When this version became effective
  validTo     DateTime? // When this version was superseded (null = current)
  isCurrent   Boolean   @default(true) // Fast lookup for current version

  caseId                String
  amount                Decimal       @db.Decimal(10, 2) // Immutable after creation
  method                PaymentMethod // Immutable after creation
  status                PaymentStatus // Can change (pending→succeeded/failed)
  stripePaymentIntentId String?
  stripePaymentMethodId String?
  receiptUrl            String?
  failureReason         String?       @db.Text
  notes                 String?       @db.Text
  createdAt             DateTime      @default(now()) // When this payment was originally created
  updatedAt             DateTime      @updatedAt // When this version was created
  createdBy             String

  case    Case @relation(fields: [caseId], references: [id], onDelete: Cascade)
  creator User @relation(fields: [createdBy], references: [id])

  @@unique([businessKey, version]) // Each version is unique
  @@index([businessKey, isCurrent]) // Fast current version lookup
  @@index([validFrom, validTo]) // Temporal queries
  @@index([caseId])
  @@index([status])
  @@map("payments")
}

enum PaymentMethod {
  CREDIT_CARD
  DEBIT_CARD
  ACH
  CHECK
  CASH
  INSURANCE_ASSIGNMENT
  PAYMENT_PLAN
}

enum PaymentStatus {
  PENDING
  PROCESSING
  SUCCEEDED
  FAILED
  CANCELLED
  REFUNDED
}

// Payment Plan (for installment payments)
model PaymentPlan {
  id                   String            @id @default(cuid())
  caseId               String
  totalAmount          Decimal           @db.Decimal(10, 2)
  downPayment          Decimal           @db.Decimal(10, 2)
  remainingBalance     Decimal           @db.Decimal(10, 2)
  numberOfInstallments Int
  installmentAmount    Decimal           @db.Decimal(10, 2)
  frequency            PaymentFrequency
  startDate            DateTime
  nextPaymentDue       DateTime?
  status               PaymentPlanStatus @default(ACTIVE)
  createdAt            DateTime          @default(now())
  updatedAt            DateTime          @updatedAt
  createdBy            String

  installments PaymentPlanInstallment[]

  @@index([caseId])
  @@index([status])
  @@map("payment_plans")
}

// Payment Plan Installment
model PaymentPlanInstallment {
  id                String                       @id @default(cuid())
  paymentPlanId     String
  installmentNumber Int
  amount            Decimal                      @db.Decimal(10, 2)
  dueDate           DateTime
  status            PaymentPlanInstallmentStatus @default(PENDING)
  paidDate          DateTime?
  paymentId         String? // Link to actual Payment record
  createdAt         DateTime                     @default(now())
  updatedAt         DateTime                     @updatedAt

  paymentPlan PaymentPlan @relation(fields: [paymentPlanId], references: [id], onDelete: Cascade)

  @@index([paymentPlanId])
  @@index([status])
  @@map("payment_plan_installments")
}

enum PaymentFrequency {
  WEEKLY
  BI_WEEKLY
  MONTHLY
  QUARTERLY
}

enum PaymentPlanStatus {
  ACTIVE
  COMPLETED
  CANCELLED
  DEFAULTED
}

enum PaymentPlanInstallmentStatus {
  PENDING
  PAID
  OVERDUE
  CANCELLED
}

// Insurance Assignment (for insurance claim tracking)
model InsuranceAssignment {
  id               String                    @id @default(cuid())
  caseId           String
  insuranceCompany String
  policyNumber     String
  policyHolderName String
  assignedAmount   Decimal                   @db.Decimal(10, 2)
  claimNumber      String?
  status           InsuranceAssignmentStatus @default(PENDING)
  submittedDate    DateTime?
  approvedDate     DateTime?
  paidDate         DateTime?
  notes            String?                   @db.Text
  createdAt        DateTime                  @default(now())
  updatedAt        DateTime                  @updatedAt
  createdBy        String

  @@index([caseId])
  @@index([status])
  @@map("insurance_assignments")
}

enum InsuranceAssignmentStatus {
  PENDING
  SUBMITTED
  UNDER_REVIEW
  APPROVED
  PARTIALLY_APPROVED
  DENIED
  PAID
  CANCELLED
}

// Memorial page
model Memorial {
  id                String   @id @default(cuid())
  caseId            String   @unique
  slug              String   @unique
  isPublic          Boolean  @default(true)
  allowPhotoUploads Boolean  @default(true)
  allowTributes     Boolean  @default(true)
  allowGuestbook    Boolean  @default(true)
  theme             String   @default("default")
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  case             Case             @relation(fields: [caseId], references: [id], onDelete: Cascade)
  photos           Photo[]
  videos           Video[]
  tributes         Tribute[]
  guestbookEntries GuestbookEntry[]

  @@index([slug])
  @@map("memorials")
}

// Photo
// SCD Type 2: Photo metadata changes (caption edits) are tracked with version history
model Photo {
  id          String    @id @default(cuid()) // Row ID (technical key)
  businessKey String // Immutable business identifier
  version     Int       @default(1) // Version number (increments on caption edit)
  validFrom   DateTime  @default(now()) // When this version became effective
  validTo     DateTime? // When this version was superseded (null = current)
  isCurrent   Boolean   @default(true) // Fast lookup for current version

  memorialId   String
  caseId       String
  url          String
  storageKey   String // S3/Vercel Blob key for deletion
  thumbnailUrl String?
  caption      String?  @db.Text
  uploadedBy   String
  uploadedAt   DateTime @default(now()) // When photo was originally uploaded
  width        Int?
  height       Int?
  fileSize     Int
  mimeType     String
  createdAt    DateTime @default(now()) // When this photo was originally created
  updatedAt    DateTime @updatedAt // When this version was created

  memorial Memorial @relation(fields: [memorialId], references: [id], onDelete: Cascade)
  uploader User     @relation(fields: [uploadedBy], references: [id])

  @@unique([businessKey, version]) // Each version is unique
  @@index([businessKey, isCurrent]) // Fast current version lookup
  @@index([validFrom, validTo]) // Temporal queries
  @@index([memorialId, isCurrent]) // Fast memorial photos lookup
  @@index([caseId, isCurrent]) // Fast case photos lookup (for display on case page)
  @@index([uploadedBy])
  @@map("photos")
}

// Video
model Video {
  id             String   @id @default(cuid())
  memorialId     String
  url            String
  thumbnailUrl   String?
  title          String?
  description    String?  @db.Text
  uploadedBy     String
  uploadedByName String
  uploadedAt     DateTime @default(now())
  duration       Int? // in seconds
  fileSize       Int
  mimeType       String

  memorial Memorial @relation(fields: [memorialId], references: [id], onDelete: Cascade)
  uploader User     @relation(fields: [uploadedBy], references: [id])

  @@index([memorialId])
  @@map("videos")
}

// Tribute message
model Tribute {
  id          String   @id @default(cuid())
  memorialId  String
  authorName  String
  authorEmail String?
  message     String   @db.Text
  isPublic    Boolean  @default(true)
  isApproved  Boolean  @default(false)
  createdAt   DateTime @default(now())

  memorial Memorial @relation(fields: [memorialId], references: [id], onDelete: Cascade)

  @@index([memorialId])
  @@index([isApproved])
  @@map("tributes")
}

// Guestbook entry
model GuestbookEntry {
  id         String   @id @default(cuid())
  memorialId String
  name       String
  email      String?
  message    String   @db.Text
  city       String?
  state      String?  @db.Char(2)
  createdAt  DateTime @default(now())

  memorial Memorial @relation(fields: [memorialId], references: [id], onDelete: Cascade)

  @@index([memorialId])
  @@map("guestbook_entries")
}

// Document
model Document {
  id        String         @id @default(cuid())
  caseId    String
  type      DocumentType
  name      String
  url       String
  fileSize  Int
  mimeType  String
  status    DocumentStatus @default(ACTIVE)
  createdAt DateTime       @default(now())
  updatedAt DateTime       @updatedAt

  case Case @relation(fields: [caseId], references: [id], onDelete: Cascade)

  @@index([caseId])
  @@map("documents")
}

enum DocumentType {
  CONTRACT
  DEATH_CERTIFICATE
  SERVICE_PROGRAM
  INSURANCE_DOCUMENT
  RECEIPT
  OTHER
}

enum DocumentStatus {
  ACTIVE
  ARCHIVED
  DELETED
}

// Task
model Task {
  id          String     @id @default(cuid())
  caseId      String
  title       String
  description String?    @db.Text
  status      TaskStatus @default(PENDING)
  assignedTo  String?
  dueDate     DateTime?
  completedAt DateTime?
  createdAt   DateTime   @default(now())
  updatedAt   DateTime   @updatedAt
  createdBy   String

  case     Case  @relation(fields: [caseId], references: [id], onDelete: Cascade)
  creator  User  @relation("CreatedTasks", fields: [createdBy], references: [id])
  assignee User? @relation("AssignedTasks", fields: [assignedTo], references: [id])

  @@index([caseId])
  @@index([status])
  @@index([assignedTo])
  @@map("tasks")
}

enum TaskStatus {
  PENDING
  IN_PROGRESS
  COMPLETED
  CANCELLED
}

// Family Invitation (invite family members to portal)
// SCD Type 2: Tracks invitation status changes for audit
model FamilyInvitation {
  id          String    @id @default(cuid()) // Row ID
  businessKey String // Immutable identifier
  version     Int       @default(1) // Version number
  validFrom   DateTime  @default(now()) // When this version became effective
  validTo     DateTime? // When superseded
  isCurrent   Boolean   @default(true) // Current version flag

  caseId       String
  email        String
  name         String
  phone        String?
  relationship String? // Relationship to decedent
  role         CaseMemberRole @default(FAMILY_MEMBER)
  permissions  Json           @default("{}")

  status     InvitationStatus @default(PENDING)
  token      String           @unique // Secure magic link token
  expiresAt  DateTime // Token expiration
  acceptedAt DateTime?
  revokedAt  DateTime?

  sentBy    String
  createdAt DateTime @default(now()) // Original invitation time
  updatedAt DateTime @updatedAt

  case   Case @relation(fields: [caseId], references: [id], onDelete: Cascade)
  sender User @relation(fields: [sentBy], references: [id])

  @@unique([businessKey, version])
  @@index([businessKey, isCurrent])
  @@index([validFrom, validTo])
  @@index([caseId, isCurrent])
  @@index([email])
  @@index([token])
  @@index([status])
  @@map("family_invitations")
}

enum InvitationStatus {
  PENDING
  ACCEPTED
  EXPIRED
  REVOKED
}

// Internal Note (staff-only case notes)
// SCD Type 2: Tracks edit history of notes for audit trail
model InternalNote {
  id          String    @id @default(cuid()) // Row ID (technical key)
  businessKey String // Immutable business identifier
  version     Int       @default(1) // Version number (increments on edit)
  validFrom   DateTime  @default(now()) // When this version became effective
  validTo     DateTime? // When this version was superseded (null = current)
  isCurrent   Boolean   @default(true) // Fast lookup for current version

  caseId    String
  content   String   @db.Text
  createdBy String
  createdAt DateTime @default(now()) // When note was originally created
  updatedAt DateTime @updatedAt // When this version was created

  case    Case @relation(fields: [caseId], references: [id], onDelete: Cascade)
  creator User @relation(fields: [createdBy], references: [id])

  @@unique([businessKey, version]) // Each version is unique
  @@index([businessKey, isCurrent]) // Fast current version lookup
  @@index([validFrom, validTo]) // Temporal queries
  @@index([caseId, isCurrent]) // Fast case notes lookup
  @@index([createdBy])
  @@map("internal_notes")
}

// Audit Log (immutable for compliance)
model AuditLog {
  id         String   @id @default(cuid())
  userId     String
  action     String // e.g. "case.create", "contract.sign", "payment.process"
  entityType String // e.g. "Case", "Contract", "Payment"
  entityId   String? // ID of affected entity
  metadata   Json     @default("{}")
  ipAddress  String?
  userAgent  String?  @db.Text
  timestamp  DateTime @default(now())

  user User @relation(fields: [userId], references: [id])

  @@index([userId])
  @@index([action])
  @@index([entityType, entityId])
  @@index([timestamp])
  @@map("audit_logs")
}

// Product Catalog (caskets, urns, merchandise)
model ProductCatalog {
  id            String          @id @default(cuid())
  funeralHomeId String?
  sku           String          @unique
  name          String
  description   String          @db.Text
  category      ProductCategory
  price         Decimal         @db.Decimal(10, 2)
  imageUrl      String?
  isAvailable   Boolean         @default(true)
  metadata      Json            @default("{}")
  displayOrder  Int             @default(0)
  createdAt     DateTime        @default(now())
  updatedAt     DateTime        @updatedAt

  funeralHome FuneralHome? @relation(fields: [funeralHomeId], references: [id])

  @@index([funeralHomeId])
  @@index([category])
  @@index([isAvailable])
  @@map("product_catalog")
}

enum ProductCategory {
  CASKET
  URN
  VAULT
  FLOWERS
  MEMORIAL_CARDS
  GUEST_BOOK
  JEWELRY
  KEEPSAKE
  MISCELLANEOUS
}

// Service Catalog (embalming, viewing, cremation, etc)
model ServiceCatalog {
  id            String      @id @default(cuid())
  funeralHomeId String?
  code          String      @unique
  name          String
  description   String      @db.Text
  serviceType   ServiceType
  price         Decimal     @db.Decimal(10, 2)
  isRequired    Boolean     @default(false)
  isAvailable   Boolean     @default(true)
  displayOrder  Int         @default(0)
  createdAt     DateTime    @default(now())
  updatedAt     DateTime    @updatedAt

  funeralHome FuneralHome? @relation(fields: [funeralHomeId], references: [id])

  @@index([funeralHomeId])
  @@index([serviceType])
  @@index([isAvailable])
  @@map("service_catalog")
}

// Contract Template (with variable substitution)
model ContractTemplate {
  id            String       @id @default(cuid())
  funeralHomeId String?
  name          String
  description   String?
  serviceType   ServiceType?
  content       String       @db.Text
  variables     Json         @default("[]")
  isDefault     Boolean      @default(false)
  version       Int          @default(1)
  isActive      Boolean      @default(true)
  createdAt     DateTime     @default(now())
  updatedAt     DateTime     @updatedAt
  createdBy     String

  funeralHome FuneralHome? @relation(fields: [funeralHomeId], references: [id])
  creator     User         @relation(fields: [createdBy], references: [id])

  @@index([funeralHomeId])
  @@index([serviceType])
  @@index([isDefault])
  @@index([isActive])
  @@map("contract_templates")
}

// ============================================================================
// CRM & Marketing System Models
// ============================================================================

// Lead (SCD Type 2)
model Lead {
  id          String    @id @default(cuid())
  businessKey String
  version     Int       @default(1)
  validFrom   DateTime  @default(now())
  validTo     DateTime?
  isCurrent   Boolean   @default(true)

  funeralHomeId     String
  firstName         String
  lastName          String
  email             String?
  phone             String?
  status            LeadStatus
  source            LeadSource
  type              LeadType
  score             Int        @default(0)
  assignedTo        String?
  referralSourceId  String?
  notes             String?    @db.Text
  lastContactedAt   DateTime?
  convertedToCaseId String?
  createdAt         DateTime   @default(now())
  updatedAt         DateTime   @updatedAt
  createdBy         String

  funeralHome    FuneralHome     @relation(fields: [funeralHomeId], references: [id])
  assignedStaff  User?           @relation("AssignedLeads", fields: [assignedTo], references: [id])
  referralSource ReferralSource? @relation(fields: [referralSourceId], references: [id])
  convertedCase  Case?           @relation("ConvertedFromLead", fields: [convertedToCaseId], references: [id])
  interactions   Interaction[]
  emails         Email[]
  phoneCalls     PhoneCall[]

  @@unique([businessKey, version])
  @@index([businessKey, isCurrent])
  @@index([validFrom, validTo])
  @@index([funeralHomeId])
  @@index([status])
  @@index([score])
  @@index([assignedTo])
  @@map("leads")
}

enum LeadStatus {
  NEW
  CONTACTED
  QUALIFIED
  NURTURING
  CONVERTED
  LOST
  ARCHIVED
}

enum LeadSource {
  WEBSITE
  PHONE
  EMAIL
  REFERRAL
  SOCIAL_MEDIA
  EVENT
  DIRECT_MAIL
  OTHER
}

enum LeadType {
  AT_NEED
  PRE_NEED
  GENERAL_INQUIRY
}

// Contact (SCD Type 2)
model Contact {
  id          String    @id @default(cuid())
  businessKey String
  version     Int       @default(1)
  validFrom   DateTime  @default(now())
  validTo     DateTime?
  isCurrent   Boolean   @default(true)

  funeralHomeId          String
  firstName              String
  lastName               String
  email                  String?
  phone                  String?
  alternatePhone         String?
  address                String?
  city                   String?
  state                  String?
  zipCode                String?
  type                   ContactType
  relationshipType       RelationshipType?
  birthDate              DateTime?
  notes                  String?            @db.Text
  doNotContact           Boolean            @default(false)
  emailOptIn             Boolean            @default(false)
  smsOptIn               Boolean            @default(false)
  tags                   String[]           @default([])
  mergedIntoContactId    String?
  // Funeral-specific enhancements
  isVeteran              Boolean            @default(false)
  militaryBranch         MilitaryBranch?
  religiousAffiliation   String?
  culturalPreferences    String[]           @default([])
  dietaryRestrictions    String[]           @default([])
  languagePreference     LanguagePreference @default(EN)
  // Grief journey tracking
  griefStage             GriefStage?
  griefJourneyStartedAt  DateTime?
  decedentRelationshipId String? // Link to FamilyRelationship
  serviceAnniversaryDate DateTime?
  lastGriefCheckIn       DateTime?
  createdAt              DateTime           @default(now())
  updatedAt              DateTime           @updatedAt
  createdBy              String

  funeralHome           FuneralHome          @relation(fields: [funeralHomeId], references: [id])
  mergedInto            Contact?             @relation("MergedContacts", fields: [mergedIntoContactId], references: [id])
  mergedContacts        Contact[]            @relation("MergedContacts")
  interactions          Interaction[]
  sourceRelationships   FamilyRelationship[] @relation("SourceContact")
  targetRelationships   FamilyRelationship[] @relation("TargetContact")
  decedentRelationships FamilyRelationship[] @relation("Decedent")
  emails                Email[]
  phoneCalls            PhoneCall[]

  @@unique([businessKey, version])
  @@index([businessKey, isCurrent])
  @@index([validFrom, validTo])
  @@index([funeralHomeId])
  @@index([email])
  @@index([phone])
  @@index([griefStage])
  @@index([serviceAnniversaryDate])
  @@map("contacts")
}

enum ContactType {
  PRIMARY
  SECONDARY
  PROFESSIONAL
  REFERRAL
}

enum RelationshipType {
  SPOUSE
  CHILD
  PARENT
  SIBLING
  FRIEND
  CLERGY
  ATTORNEY
  OTHER
}

enum GriefStage {
  SHOCK
  DENIAL
  ANGER
  BARGAINING
  DEPRESSION
  ACCEPTANCE
}

enum MilitaryBranch {
  ARMY
  NAVY
  AIR_FORCE
  MARINES
  COAST_GUARD
  SPACE_FORCE
}

enum LanguagePreference {
  EN
  ES
  FR
  DE
  PL
  IT
  ZH
  OTHER
}

// FamilyRelationship (SCD Type 2)
// Maps relationships between contacts for family network visualization
model FamilyRelationship {
  id          String    @id @default(cuid())
  businessKey String
  version     Int       @default(1)
  validFrom   DateTime  @default(now())
  validTo     DateTime?
  isCurrent   Boolean   @default(true)

  funeralHomeId    String
  sourceContactId  String
  targetContactId  String
  relationshipType FamilyRelationshipType
  isPrimaryContact Boolean                @default(false)
  decedentId       String? // Contact ID of deceased
  notes            String?                @db.Text
  createdAt        DateTime               @default(now())
  updatedAt        DateTime               @updatedAt
  createdBy        String

  funeralHome   FuneralHome @relation(fields: [funeralHomeId], references: [id])
  sourceContact Contact     @relation("SourceContact", fields: [sourceContactId], references: [id])
  targetContact Contact     @relation("TargetContact", fields: [targetContactId], references: [id])
  decedent      Contact?    @relation("Decedent", fields: [decedentId], references: [id])

  @@unique([businessKey, version])
  @@index([businessKey, isCurrent])
  @@index([validFrom, validTo])
  @@index([funeralHomeId])
  @@index([sourceContactId])
  @@index([targetContactId])
  @@index([decedentId])
  @@map("family_relationships")
}

enum FamilyRelationshipType {
  SPOUSE
  CHILD
  PARENT
  SIBLING
  GRANDCHILD
  GRANDPARENT
  NIECE_NEPHEW
  AUNT_UNCLE
  COUSIN
  IN_LAW
  STEP_RELATION
  FRIEND
  OTHER
}

// Campaign (SCD Type 2)
model Campaign {
  id          String    @id @default(cuid())
  businessKey String
  version     Int       @default(1)
  validFrom   DateTime  @default(now())
  validTo     DateTime?
  isCurrent   Boolean   @default(true)

  funeralHomeId  String
  name           String
  description    String?        @db.Text
  type           CampaignType
  status         CampaignStatus
  subject        String?
  content        String?        @db.Text
  segmentTags    String[]       @default([])
  scheduledFor   DateTime?
  sentAt         DateTime?
  targetCount    Int            @default(0)
  sentCount      Int            @default(0)
  openedCount    Int            @default(0)
  clickedCount   Int            @default(0)
  convertedCount Int            @default(0)
  createdAt      DateTime       @default(now())
  updatedAt      DateTime       @updatedAt
  createdBy      String

  funeralHome FuneralHome @relation(fields: [funeralHomeId], references: [id])

  @@unique([businessKey, version])
  @@index([businessKey, isCurrent])
  @@index([validFrom, validTo])
  @@index([funeralHomeId])
  @@index([status])
  @@map("campaigns")
}

enum CampaignType {
  EMAIL
  SMS
  DIRECT_MAIL
  MIXED
}

enum CampaignStatus {
  DRAFT
  SCHEDULED
  SENDING
  SENT
  PAUSED
  ARCHIVED
}

// Interaction (immutable - no SCD2)
model Interaction {
  id            String               @id @default(cuid())
  funeralHomeId String
  leadId        String?
  contactId     String?
  caseId        String?
  type          InteractionType
  direction     InteractionDirection
  subject       String
  body          String?              @db.Text
  outcome       String?              @db.Text
  scheduledFor  DateTime?
  completedAt   DateTime?
  duration      Int?
  staffId       String
  createdAt     DateTime             @default(now())

  funeralHome   FuneralHome    @relation(fields: [funeralHomeId], references: [id])
  lead          Lead?          @relation(fields: [leadId], references: [id])
  contact       Contact?       @relation(fields: [contactId], references: [id])
  case          Case?          @relation(fields: [caseId], references: [id])
  staff         User           @relation("StaffInteractions", fields: [staffId], references: [id])
  calendarEvent CalendarEvent?
  phoneCall     PhoneCall?

  @@index([funeralHomeId])
  @@index([leadId])
  @@index([contactId])
  @@index([caseId])
  @@index([staffId])
  @@index([createdAt])
  @@map("interactions")
}

enum InteractionType {
  PHONE_CALL
  EMAIL
  MEETING
  VISIT
  NOTE
  TASK
}

enum InteractionDirection {
  INBOUND
  OUTBOUND
}

// Referral Source (SCD Type 2)
model ReferralSource {
  id          String    @id @default(cuid())
  businessKey String
  version     Int       @default(1)
  validFrom   DateTime  @default(now())
  validTo     DateTime?
  isCurrent   Boolean   @default(true)

  funeralHomeId      String
  name               String
  type               ReferralSourceType
  contactPerson      String?
  email              String?
  phone              String?
  address            String?
  notes              String?            @db.Text
  isActive           Boolean            @default(true)
  totalReferrals     Int                @default(0)
  convertedReferrals Int                @default(0)
  createdAt          DateTime           @default(now())
  updatedAt          DateTime           @updatedAt
  createdBy          String

  funeralHome FuneralHome @relation(fields: [funeralHomeId], references: [id])
  leads       Lead[]

  @@unique([businessKey, version])
  @@index([businessKey, isCurrent])
  @@index([validFrom, validTo])
  @@index([funeralHomeId])
  @@map("referral_sources")
}

enum ReferralSourceType {
  FUNERAL_HOME
  HOSPICE
  HOSPITAL
  CLERGY
  ATTORNEY
  FAMILY
  ONLINE
  OTHER
}

// Email (immutable event log - no SCD2)
// Bi-directional email sync from Microsoft 365 / Gmail
model Email {
  id            String         @id @default(cuid())
  funeralHomeId String
  provider      EmailProvider
  externalId    String? // Provider's message ID (for deduplication)
  from          String
  to            String[]       @default([])
  cc            String[]       @default([])
  bcc           String[]       @default([])
  subject       String
  body          String         @db.Text // Plain text
  htmlBody      String?        @db.Text
  threadId      String? // For conversation threading
  inReplyTo     String? // Parent email ID
  direction     EmailDirection
  sentAt        DateTime?
  receivedAt    DateTime?
  isRead        Boolean        @default(false)
  contactId     String? // Matched contact
  leadId        String? // Matched lead
  caseId        String? // Matched case
  attachments   Json           @default("[]") // Array of attachment metadata
  createdAt     DateTime       @default(now())
  syncedBy      String? // User who triggered sync

  funeralHome FuneralHome @relation(fields: [funeralHomeId], references: [id])
  contact     Contact?    @relation(fields: [contactId], references: [id])
  lead        Lead?       @relation(fields: [leadId], references: [id])
  case        Case?       @relation(fields: [caseId], references: [id])

  @@unique([provider, externalId]) // Prevent duplicate syncs
  @@index([funeralHomeId])
  @@index([contactId])
  @@index([leadId])
  @@index([caseId])
  @@index([threadId])
  @@index([from])
  @@index([sentAt])
  @@index([receivedAt])
  @@index([createdAt])
  @@map("emails")
}

enum EmailProvider {
  MICROSOFT
  GOOGLE
  INTERNAL
}

enum EmailDirection {
  INBOUND
  OUTBOUND
}

// OAuth Token storage for email sync
model OAuthToken {
  id           String        @id @default(cuid())
  userId       String
  provider     OAuthProvider
  accessToken  String        @db.Text
  refreshToken String?       @db.Text
  expiresAt    DateTime
  scope        String
  createdAt    DateTime      @default(now())
  updatedAt    DateTime      @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, provider]) // One token per provider per user
  @@index([userId])
  @@index([expiresAt])
  @@map("oauth_tokens")
}

enum OAuthProvider {
  MICROSOFT
  GOOGLE
}

// CalendarEvent (immutable event log - no SCD2)
// Synced with external calendar providers (Microsoft 365, Google Calendar)
model CalendarEvent {
  id             String           @id @default(cuid())
  funeralHomeId  String
  interactionId  String?          @unique // Optional link to Interaction
  provider       CalendarProvider
  externalId     String? // Provider's event ID
  title          String
  description    String?          @db.Text
  startTime      DateTime
  endTime        DateTime
  location       String?
  attendees      Json             @default("[]") // Array of Attendee objects
  reminders      Json             @default("[]") // Array of Reminder objects
  recurrenceRule String?          @db.Text // iCalendar RRULE format
  isCancelled    Boolean          @default(false)
  createdBy      String
  createdAt      DateTime         @default(now())
  updatedAt      DateTime         @updatedAt
  caseId         String?

  funeralHome FuneralHome  @relation(fields: [funeralHomeId], references: [id])
  interaction Interaction? @relation(fields: [interactionId], references: [id])
  case        Case?        @relation(fields: [caseId], references: [id])
  creator     User         @relation("CalendarEventCreator", fields: [createdBy], references: [id])

  @@unique([provider, externalId]) // Prevent duplicate syncs
  @@index([funeralHomeId])
  @@index([interactionId])
  @@index([caseId])
  @@index([startTime])
  @@index([endTime])
  @@index([createdBy])
  @@index([isCancelled])
  @@map("calendar_events")
}

enum CalendarProvider {
  MICROSOFT
  GOOGLE
}

// PhoneCall (immutable event log - no SCD2)
// Tracks phone calls from Twilio/RingCentral with optional recording/transcription
model PhoneCall {
  id             String        @id @default(cuid())
  funeralHomeId  String
  interactionId  String?       @unique // Optional link to Interaction
  provider       PhoneProvider
  externalCallId String? // Provider's call SID/ID
  from           String // E.164 format
  to             String // E.164 format
  direction      CallDirection
  status         CallStatus
  duration       Int? // Duration in seconds
  recordingUrl   String? // URL to call recording
  transcription  String?       @db.Text // Call transcription
  consentGiven   Boolean       @default(false) // Recording consent flag
  outcome        String?       @db.Text // Call outcome notes
  contactId      String? // Matched contact
  leadId         String? // Matched lead
  caseId         String? // Matched case
  staffId        String // Staff member who made/received call
  startedAt      DateTime?
  endedAt        DateTime?
  createdAt      DateTime      @default(now())

  funeralHome FuneralHome  @relation(fields: [funeralHomeId], references: [id])
  interaction Interaction? @relation(fields: [interactionId], references: [id])
  contact     Contact?     @relation(fields: [contactId], references: [id])
  lead        Lead?        @relation(fields: [leadId], references: [id])
  case        Case?        @relation(fields: [caseId], references: [id])
  staff       User         @relation("PhoneCallStaff", fields: [staffId], references: [id])

  @@unique([provider, externalCallId]) // Prevent duplicate logging
  @@index([funeralHomeId])
  @@index([interactionId])
  @@index([contactId])
  @@index([leadId])
  @@index([caseId])
  @@index([staffId])
  @@index([startedAt])
  @@index([createdAt])
  @@map("phone_calls")
}

enum PhoneProvider {
  TWILIO
  RINGCENTRAL
}

enum CallDirection {
  INBOUND
  OUTBOUND
}

enum CallStatus {
  INITIATED
  RINGING
  IN_PROGRESS
  COMPLETED
  FAILED
  BUSY
  NO_ANSWER
  CANCELLED
}

// PrePlanningAppointment (SCD Type 2: Full history tracked)
// Manages pre-need consultation appointments with funeral directors
// Business Rules:
// - Appointments only 8am-5pm Mon-Fri
// - Minimum 1 hour duration
// - Maximum 4 appointments per director per day
// - No double-booking (overlapping appointments)
// - Lunch break 12-1pm automatically blocks availability
// - 24-hour cancellation notice required
// - Automated reminders at 24 hours and 1 hour before
model PrePlanningAppointment {
  id          String    @id @default(cuid()) // Row ID (technical key)
  businessKey String // Immutable business identifier (directorId:timestamp)
  version     Int       @default(1) // Version number (increments on each change)
  validFrom   DateTime  @default(now()) // When this version became effective
  validTo     DateTime? // When this version was superseded (null = current)
  isCurrent   Boolean   @default(true) // Fast lookup for current version

  funeralHomeId     String
  directorId        String
  directorName      String
  familyName        String
  familyEmail       String
  familyPhone       String
  appointmentDate   DateTime // Date of appointment (time component ignored)
  startTime         DateTime // Start time (full datetime)
  endTime           DateTime // End time (full datetime)
  duration          Int // Duration in minutes
  notes             String?           @db.Text
  status            AppointmentStatus
  reminderEmailSent Boolean           @default(false)
  reminderSmsSent   Boolean           @default(false)
  completedAt       DateTime?
  cancelledAt       DateTime?
  cancelReason      String?           @db.Text
  createdAt         DateTime          @default(now()) // When originally created
  updatedAt         DateTime          @updatedAt // When this version created
  createdBy         String

  funeralHome FuneralHome @relation(fields: [funeralHomeId], references: [id])

  @@unique([businessKey, version]) // Each temporal version unique
  @@index([businessKey, isCurrent]) // Fast current version lookup
  @@index([validFrom, validTo]) // Temporal queries
  @@index([funeralHomeId]) // Find funeral home's appointments
  @@index([directorId]) // Find director's appointments
  @@index([familyEmail]) // Find family appointments
  @@index([appointmentDate]) // Find appointments by date
  @@index([status]) // Find by status
  @@index([reminderEmailSent]) // Find appointments needing reminders
  @@map("pre_planning_appointments")
}

enum AppointmentStatus {
  SCHEDULED // Confirmed appointment
  CONFIRMED // Confirmed by director/family
  COMPLETED // Appointment completed
  CANCELLED // Cancelled by family/director
  NO_SHOW // Family did not attend
}

// DriverAssignment (SCD Type 2: Full history tracked)
// Manages driver assignments to funeral home removals, transfers, and processions
// Business Rules:
// - Minimum 1-hour rest period between assignments (validated with 60-minute buffer)
// - Duration: 15-240 minutes
// - Mileage recorded at completion for payroll reimbursement ($0.67/mile IRS rate)
// - Assignment status tracks workflow: pending → accepted → in_progress → completed
model DriverAssignment {
  id          String    @id @default(cuid()) // Row ID (technical key)
  businessKey String // Immutable business identifier (format: funeralHomeId:eventType_caseId:driverId)
  version     Int       @default(1) // Version number (increments on each change)
  validFrom   DateTime  @default(now()) // When this version became effective
  validTo     DateTime? // When this version was superseded (null = current)
  isCurrent   Boolean   @default(true) // Fast lookup for current version

  funeralHomeId     String
  driverId          String // External ID (staff/driver reference)
  vehicleId         String? // Optional vehicle assignment
  eventType         EventType // removal, transfer, or procession
  caseId            String // Link to funeral case for labor costing
  pickupLocation    Json // Nested object: {address, city, state, zipCode, latitude?, longitude?}
  dropoffLocation   Json // Nested object: {address, city, state, zipCode, latitude?, longitude?}
  scheduledTime     DateTime // When the assignment is scheduled
  estimatedDuration Int // Duration in minutes (15-240)
  actualDuration    Int? // Actual duration if completed
  status            AssignmentStatus
  mileageStart      Int? // Odometer reading at start
  mileageEnd        Int? // Odometer reading at end
  mileageAllowance  Float? // Calculated reimbursement ($0.67/mile)
  notes             String?          @db.Text
  createdAt         DateTime         @default(now()) // When originally created
  updatedAt         DateTime         @updatedAt // When this version created
  createdBy         String // Staff ID
  updatedBy         String? // Last staff to update

  funeralHome FuneralHome @relation(fields: [funeralHomeId], references: [id])

  @@unique([businessKey, version]) // Each temporal version unique
  @@index([businessKey, isCurrent]) // Fast current version lookup
  @@index([validFrom, validTo]) // Temporal queries
  @@index([funeralHomeId]) // Find funeral home's assignments
  @@index([driverId]) // Find driver's assignments
  @@index([vehicleId]) // Find vehicle's assignments
  @@index([caseId]) // Find case's assignments for labor costing
  @@index([scheduledTime]) // Find assignments by date/time
  @@index([status]) // Find by status
  @@map("driver_assignments")
}

enum EventType {
  REMOVAL // Body removal from location
  TRANSFER // Transfer between locations
  PROCESSION // Procession/funeral service
}

enum AssignmentStatus {
  PENDING // Initial state, awaiting driver acceptance
  ACCEPTED // Driver has accepted assignment
  IN_PROGRESS // Driver has begun the assignment
  COMPLETED // Assignment completed and mileage recorded
  CANCELLED // Assignment cancelled
}

// Vehicle (SCD Type 2: Full history tracked)
// Manages funeral home vehicle fleet with maintenance and inspection tracking
// Business Rules:
// - Inspection must be current (not expired)
// - Vehicles due for maintenance cannot be assigned
// - Status tracks availability: available, in_use, maintenance, retired
// - Mileage recorded for each assignment completion
model Vehicle {
  id          String    @id @default(cuid()) // Row ID (technical key)
  businessKey String // Immutable business identifier (format: funeralHomeId:licensePlate)
  version     Int       @default(1) // Version number (increments on each change)
  validFrom   DateTime  @default(now()) // When this version became effective
  validTo     DateTime? // When this version was superseded (null = current)
  isCurrent   Boolean   @default(true) // Fast lookup for current version

  funeralHomeId       String
  vehicleType         String // hearse, limousine, van, sedan, etc.
  licensePlate        String        @unique // Must be unique per state
  vin                 String        @unique // Vehicle Identification Number
  year                Int
  make                String // Cadillac, Lincoln, Mercedes, etc.
  model               String
  color               String
  capacity            Int // Number of passengers (including driver)
  status              VehicleStatus
  mileageCurrentTotal Int // Total cumulative mileage
  lastMaintenanceDate DateTime? // Last maintenance completion date
  nextMaintenanceDate DateTime // When next maintenance is due
  lastInspectionDate  DateTime? // Last inspection completion date
  nextInspectionDate  DateTime // When next inspection is due
  acquisitionDate     DateTime // When funeral home acquired vehicle
  retirementDate      DateTime? // When vehicle was retired from service
  notes               String?       @db.Text
  createdAt           DateTime      @default(now()) // When originally created
  updatedAt           DateTime      @updatedAt // When this version created
  createdBy           String // Staff ID
  updatedBy           String? // Last staff to update

  funeralHome FuneralHome @relation(fields: [funeralHomeId], references: [id])

  @@unique([businessKey, version]) // Each temporal version unique
  @@index([businessKey, isCurrent]) // Fast current version lookup
  @@index([validFrom, validTo]) // Temporal queries
  @@index([funeralHomeId]) // Find funeral home's vehicles
  @@index([status]) // Find by status (available, in_use, maintenance)
  @@index([nextInspectionDate]) // Find vehicles with expiring inspections
  @@index([nextMaintenanceDate]) // Find vehicles due for maintenance
  @@map("vehicles")
}

enum VehicleStatus {
  AVAILABLE // Ready for assignment
  IN_USE // Currently assigned to a removal/transfer
  MAINTENANCE // In maintenance or repair
  RETIRED // No longer in service
}

// Preparation Room (embalming station)
// SCD Type 2: Temporal tracking for facility maintenance history
model PrepRoom {
  id          String    @id @default(cuid()) // Row ID (technical key)
  businessKey String // Immutable business identifier (format: funeralHomeId:roomNumber)
  version     Int       @default(1) // Version number (increments on each change)
  validFrom   DateTime  @default(now()) // When this version became effective
  validTo     DateTime? // When this version was superseded (null = current)
  isCurrent   Boolean   @default(true) // Fast lookup for current version

  funeralHomeId String
  roomNumber    String // Room identifier (e.g., "A1", "B2")
  capacity      Int // 1 or 2 (single or double embalming stations)
  status        PrepRoomStatus // available, maintenance, closed
  createdAt     DateTime       @default(now()) // When originally created
  updatedAt     DateTime       @updatedAt // When this version created
  createdBy     String // Staff ID

  reservations PrepRoomReservation[]

  @@unique([businessKey, version]) // Each temporal version unique
  @@index([businessKey, isCurrent]) // Fast current version lookup
  @@index([validFrom, validTo]) // Temporal queries
  @@index([funeralHomeId]) // Find funeral home's prep rooms
  @@index([status]) // Find by status
  @@map("prep_rooms")
}

enum PrepRoomStatus {
  AVAILABLE // Ready for reservation
  MAINTENANCE // Undergoing maintenance
  CLOSED // Not available
}

// Preparation Room Reservation
// SCD Type 2: Full audit trail of all reservations and status changes
model PrepRoomReservation {
  id          String    @id @default(cuid()) // Row ID (technical key)
  businessKey String // Immutable business identifier (format: prepRoomId:caseId:embalmerId)
  version     Int       @default(1) // Version number (increments on each change)
  validFrom   DateTime  @default(now()) // When this version became effective
  validTo     DateTime? // When this version was superseded (null = current)
  isCurrent   Boolean   @default(true) // Fast lookup for current version

  prepRoomId     String
  embalmerId     String // Staff ID
  caseId         String // Case being prepared
  familyId       String // Family ID (for tracking)
  status         PrepRoomReservationStatus
  priority       PrepRoomReservationPriority
  reservedFrom   DateTime // Scheduled start time
  reservedTo     DateTime // Scheduled end time
  checkedInAt    DateTime? // Actual check-in time
  checkedOutAt   DateTime? // Actual check-out time
  actualDuration Int? // Actual duration in minutes (calculated on checkout)
  notes          String?                     @db.Text // Prep notes or override reason
  createdAt      DateTime                    @default(now()) // When originally created
  updatedAt      DateTime                    @updatedAt // When this version created
  createdBy      String // Staff ID who created

  prepRoom PrepRoom @relation(fields: [prepRoomId], references: [id])

  @@unique([businessKey, version]) // Each temporal version unique
  @@index([businessKey, isCurrent]) // Fast current version lookup
  @@index([validFrom, validTo]) // Temporal queries
  @@index([prepRoomId, reservedFrom]) // Find conflicts for room
  @@index([embalmerId, reservedFrom]) // Find embalmer's schedule
  @@index([caseId]) // Find reservations for case
  @@index([status]) // Find by status (pending, confirmed, in_progress, completed, etc.)
  @@index([priority]) // Find urgent reservations
  @@map("prep_room_reservations")
}

enum PrepRoomReservationStatus {
  PENDING // Awaiting confirmation (30-min auto-release timeout)
  CONFIRMED // Confirmed but not yet checked in
  IN_PROGRESS // Checked in, currently in use
  COMPLETED // Checked out successfully
  AUTO_RELEASED // Released due to 30-minute timeout without check-in
  CANCELLED // Manually cancelled
}

enum PrepRoomReservationPriority {
  NORMAL // Standard reservation
  URGENT // High priority (death call, etc.)
}

// On-Call Policy
// SCD Type 2: Tracks on-call rotation policies for per-funeral-home customization
model OnCallPolicy {
  id          String    @id @default(cuid())
  businessKey String    @default(cuid())
  version     Int       @default(1)
  validFrom   DateTime  @default(now())
  validTo     DateTime?
  isCurrent   Boolean   @default(true)

  funeralHomeId                  String
  minAdvanceNoticeHours          Int      @default(48) // 24-96 hours
  maxConsecutiveWeekendsOn       Int      @default(2) // 1-3
  minRestHoursAfterShift         Int      @default(8) // 6-12
  backupDirectorRequired         Boolean  @default(true)
  fairRotationEnabled            Boolean  @default(true)
  maxOnCallPerDirectorPerQuarter Int      @default(13) // Quarter = ~13 weeks
  onCallBasePayAmount            Float    @default(150) // Flat rate per assignment
  callbackHourlyRate             Float    @default(1.5) // Multiplier for callback hours
  notes                          String?  @db.Text
  createdAt                      DateTime @default(now())
  updatedAt                      DateTime @updatedAt
  createdBy                      String

  @@unique([businessKey, version])
  @@index([businessKey, isCurrent])
  @@index([validFrom, validTo])
  @@index([funeralHomeId, isCurrent])
  @@map("on_call_policies")
}

// PTO Policy
// SCD Type 2: Tracks policy changes for audit trail and historical compliance
model PtoPolicy {
  id          String    @id @default(cuid()) // Row ID (technical key)
  businessKey String    @default(cuid()) // Funeral home + policy identifier
  version     Int       @default(1) // Version number (increments on each change)
  validFrom   DateTime  @default(now()) // When this version became effective
  validTo     DateTime? // When this version was superseded (null = current)
  isCurrent   Boolean   @default(true) // Fast lookup for current version

  funeralHomeId                String
  minAdvanceNoticeDays         Int      @default(14)
  minAdvanceNoticeHolidaysDays Int      @default(30)
  annualPtoDaysPerEmployee     Int      @default(20)
  maxConcurrentEmployeesOnPto  Int      @default(2)
  maxConsecutivePtoDays        Int      @default(10)
  roleSpecificPolicies         Json     @default("{}")
  blackoutDates                Json     @default("[]")
  enablePremiumPayForBackfill  Boolean  @default(true)
  premiumMultiplier            Float    @default(1.5)
  notes                        String?  @db.Text
  createdAt                    DateTime @default(now())
  updatedAt                    DateTime @updatedAt
  createdBy                    String

  @@unique([businessKey, version])
  @@index([businessKey, isCurrent])
  @@index([validFrom, validTo])
  @@index([funeralHomeId, isCurrent])
  @@map("pto_policies")
}

// Training Policy
// SCD Type 2: Tracks training policy changes with audit trail
model TrainingPolicy {
  id          String    @id @default(cuid())
  businessKey String    @default(cuid())
  version     Int       @default(1)
  validFrom   DateTime  @default(now())
  validTo     DateTime?
  isCurrent   Boolean   @default(true)

  funeralHomeId             String
  roleRequirements          Json     @default("{}")
  enableTrainingBackfill    Boolean  @default(true)
  backfillPremiumMultiplier Float    @default(1.25)
  defaultRenewalNoticeDays  Int      @default(60)
  approvalRequiredAboveCost Float    @default(1000)
  notes                     String?  @db.Text
  createdAt                 DateTime @default(now())
  updatedAt                 DateTime @updatedAt
  createdBy                 String

  @@unique([businessKey, version])
  @@index([businessKey, isCurrent])
  @@index([validFrom, validTo])
  @@index([funeralHomeId, isCurrent])
  @@map("training_policies")
}

// PTO Request
// SCD Type 2: Tracks all PTO requests with full audit trail
model PtoRequest {
  id          String    @id @default(cuid())
  businessKey String    @default(cuid())
  version     Int       @default(1)
  validFrom   DateTime  @default(now())
  validTo     DateTime?
  isCurrent   Boolean   @default(true)

  funeralHomeId           String
  employeeId              String
  employeeName            String
  ptoType                 String // 'vacation', 'sick_leave', 'bereavement', 'unpaid', 'personal'
  requestedDays           Int
  startDate               DateTime
  endDate                 DateTime
  reason                  String?   @db.Text
  status                  String    @default("draft") // 'draft', 'pending', 'approved', 'rejected', 'taken', 'cancelled'
  requestedAt             DateTime  @default(now())
  respondedAt             DateTime?
  respondedBy             String?
  rejectionReason         String?   @db.Text
  backfillRequirementsMet Boolean   @default(false)
  createdAt               DateTime  @default(now())
  updatedAt               DateTime  @updatedAt
  createdBy               String

  @@unique([businessKey, version])
  @@index([businessKey, isCurrent])
  @@index([validFrom, validTo])
  @@index([funeralHomeId, employeeId])
  @@index([funeralHomeId, status])
  @@index([startDate, endDate])
  @@index([status])
  @@map("pto_requests")
}

// Training Record
// Non-versioned (immutable once created) - records training events
model TrainingRecord {
  id                    String    @id @default(cuid())
  funeralHomeId         String
  employeeId            String
  employeeName          String
  trainingType          String // 'embalming', 'funeral_directing', 'restorative_art', etc.
  trainingName          String
  requiredForRole       Boolean   @default(false)
  status                String    @default("scheduled") // 'scheduled', 'in_progress', 'completed', 'cancelled', 'no_show'
  scheduledDate         DateTime?
  startDate             DateTime?
  endDate               DateTime?
  completedAt           DateTime?
  hours                 Int
  cost                  Float
  instructor            String?
  location              String?
  certificationNumber   String?   @unique
  expiresAt             DateTime?
  renewalReminderSentAt DateTime?
  notes                 String?   @db.Text
  createdAt             DateTime  @default(now())
  updatedAt             DateTime  @updatedAt
  createdBy             String

  @@index([funeralHomeId, employeeId])
  @@index([status])
  @@index([expiresAt])
  @@index([trainingType])
  @@index([completedAt])
  @@map("training_records")
}

// Backfill Assignment
// SCD Type 2: Tracks staff coverage assignments for PTO/training
model BackfillAssignment {
  id          String    @id @default(cuid())
  businessKey String    @default(cuid())
  version     Int       @default(1)
  validFrom   DateTime  @default(now())
  validTo     DateTime?
  isCurrent   Boolean   @default(true)

  funeralHomeId        String
  absenceId            String // PTO request or training record ID
  absenceType          String // 'pto', 'training', 'other'
  absenceStartDate     DateTime
  absenceEndDate       DateTime
  absenceEmployeeId    String
  absenceEmployeeName  String
  absenceEmployeeRole  String
  backfillEmployeeId   String
  backfillEmployeeName String
  backfillEmployeeRole String
  status               String    @default("suggested") // 'suggested', 'pending_confirmation', 'confirmed', 'rejected', 'cancelled', 'completed'
  suggestedAt          DateTime  @default(now())
  confirmedAt          DateTime?
  confirmedBy          String?
  rejectedAt           DateTime?
  rejectionReason      String?   @db.Text
  completedAt          DateTime?
  premiumType          String    @default("none") // 'none', 'overtime', 'holiday', 'training_coverage', 'emergency'
  premiumMultiplier    Float     @default(1.0)
  estimatedHours       Int
  actualHours          Int?
  notes                String?   @db.Text
  createdAt            DateTime  @default(now())
  updatedAt            DateTime  @updatedAt
  createdBy            String

  @@unique([businessKey, version])
  @@index([businessKey, isCurrent])
  @@index([validFrom, validTo])
  @@index([funeralHomeId, absenceId])
  @@index([funeralHomeId, status])
  @@index([backfillEmployeeId, absenceStartDate])
  @@index([absenceStartDate, absenceEndDate])
  @@index([status])
  @@map("backfill_assignments")
}

// Certification Status
// Non-versioned - tracks current certification status per employee
model CertificationStatus {
  id                    String    @id @default(cuid())
  funeralHomeId         String
  employeeId            String
  certificationId       String
  certificationName     String
  trainingRecordId      String? // Link to training record
  status                String // 'current', 'expiring_soon', 'expired', 'missing'
  expiresAt             DateTime?
  renewalDueAt          DateTime?
  renewalReminderSentAt DateTime?
  notes                 String?   @db.Text
  createdAt             DateTime  @default(now())
  updatedAt             DateTime  @updatedAt

  @@unique([funeralHomeId, employeeId, certificationId])
  @@index([funeralHomeId, employeeId])
  @@index([expiresAt])
  @@index([status])
  @@index([renewalDueAt])
  @@map("certification_statuses")
}

// Lead Scoring Policy
// SCD Type 2: Tracks historical lead scoring policy configurations per funeral home
model LeadScoringPolicy {
  id            String    @id @default(cuid())
  businessKey   String    @default(cuid()) // Policy identifier
  version       Int       @default(1)
  validFrom     DateTime  @default(now())
  validTo       DateTime?
  isCurrent     Boolean   @default(true)
  funeralHomeId String

  // Lead Type Scoring (at-need, pre-need, general inquiry)
  atNeedInitialScore  Int @default(80) // 0-100
  preNeedInitialScore Int @default(30) // 0-100
  generalInquiryScore Int @default(40) // 0-100

  // Score Thresholds for categorization
  hotLeadThreshold  Int @default(70) // Score >= this = hot
  warmLeadThreshold Int @default(50) // Score >= this = warm
  coldLeadThreshold Int @default(50) // Score < this = cold

  // Inactive Lead Handling
  inactiveThresholdDays Int     @default(14) // Days without contact
  enableAutoArchive     Boolean @default(false) // Auto-archive inactive?
  archiveAfterDays      Int     @default(90) // Days before auto-archiving

  // Score Adjustment Factors
  contactMethodBonus   Int @default(10) // Bonus for email + phone
  referralSourceBonus  Int @default(15) // Bonus for referrals
  emailEngagementBonus Int @default(2) // Per email open
  phoneEngagementBonus Int @default(5) // Per phone contact

  // Required Fields for Creation
  requirePhoneOrEmail Boolean @default(true)
  requireFirstName    Boolean @default(true)
  requireLastName     Boolean @default(true)

  // Lead Source Preferences
  preferredSources  String[] @default(["referral", "event"])
  disallowedSources String[] @default([])

  // Audit Trail
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  createdBy String
  updatedBy String?
  reason    String?  @db.Text // Reason for policy change

  @@unique([businessKey, version])
  @@index([businessKey, isCurrent])
  @@index([validFrom, validTo])
  @@index([funeralHomeId, isCurrent])
  @@index([funeralHomeId, validFrom])
  @@map("lead_scoring_policies")
}

// Lead To Case Conversion Policy
// SCD Type 2: Tracks historical lead-to-case conversion policies per funeral home
model LeadToCaseConversionPolicy {
  id            String    @id @default(cuid())
  businessKey   String    @default(cuid()) // Policy identifier
  version       Int       @default(1)
  validFrom     DateTime  @default(now())
  validTo       DateTime?
  isCurrent     Boolean   @default(true)
  funeralHomeId String

  // Lead To Case Conversion Rules
  defaultCaseStatus       String  @default("inquiry") // 'inquiry' or 'active'
  requireDecedentName     Boolean @default(true) // Must have decedent name
  autoAssignToLeadStaff   Boolean @default(true) // Auto-assign case to lead's assignee
  preserveLeadNotes       Boolean @default(true) // Copy lead notes to case
  createInteractionRecord Boolean @default(true) // Log conversion as interaction

  // Audit Trail
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  createdBy String
  updatedBy String?
  reason    String?  @db.Text // Reason for policy change

  @@unique([businessKey, version])
  @@index([businessKey, isCurrent])
  @@index([validFrom, validTo])
  @@index([funeralHomeId, isCurrent])
  @@map("lead_to_case_conversion_policies")
}

// Note Management Policy
// SCD Type 2: Tracks historical note management policies per funeral home
model NoteManagementPolicy {
  id            String    @id @default(cuid())
  businessKey   String    @default(cuid()) // Policy identifier
  version       Int       @default(1)
  validFrom     DateTime  @default(now())
  validTo       DateTime?
  isCurrent     Boolean   @default(true)
  funeralHomeId String

  // Note Management Rules
  maxContentLength         Int     @default(10000) // Maximum characters allowed
  minContentLength         Int     @default(1) // Minimum characters required
  requireContentValidation Boolean @default(true) // Enforce validation rules
  enableAutoArchive        Boolean @default(false) // Enable automatic archival
  autoArchiveAfterDays     Int? // Days before auto-archive (null = disabled)

  // Audit Trail
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  createdBy String
  updatedBy String?
  reason    String?  @db.Text // Reason for policy change

  @@unique([businessKey, version])
  @@index([businessKey, isCurrent])
  @@index([validFrom, validTo])
  @@index([funeralHomeId, isCurrent])
  @@map("note_management_policies")
}

// Interaction Management Policy
// SCD Type 2: Tracks historical interaction management policies per funeral home
model InteractionManagementPolicy {
  id            String    @id @default(cuid())
  businessKey   String    @default(cuid()) // Policy identifier
  version       Int       @default(1)
  validFrom     DateTime  @default(now())
  validTo       DateTime?
  isCurrent     Boolean   @default(true)
  funeralHomeId String

  // Interaction Management Rules
  maxSubjectLength                 Int     @default(200)
  minSubjectLength                 Int     @default(1)
  maxOutcomeLength                 Int     @default(1000)
  maxDurationMinutes               Int? // null = no limit
  requireAssociation               Boolean @default(true)
  allowScheduledInteractions       Boolean @default(true)
  autoCompleteUncompletedAfterDays Int? // null = disabled
  allowOutcomeUpdate               Boolean @default(false)
  autoArchiveCompletedAfterDays    Int? // null = disabled

  // Audit Trail
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  createdBy String
  updatedBy String?
  reason    String?  @db.Text // Reason for policy change

  @@unique([businessKey, version])
  @@index([businessKey, isCurrent])
  @@index([validFrom, validTo])
  @@index([funeralHomeId, isCurrent])
  @@map("interaction_management_policies")
}

// Invitation Management Policy
// SCD Type 2: Tracks historical invitation management policies per funeral home
model InvitationManagementPolicy {
  id            String    @id @default(cuid())
  businessKey   String    @default(cuid()) // Policy identifier
  version       Int       @default(1)
  validFrom     DateTime  @default(now())
  validTo       DateTime?
  isCurrent     Boolean   @default(true)
  funeralHomeId String

  // Invitation Management Rules
  tokenLengthBytes                 Int     @default(32)
  expirationDays                   Int     @default(7)
  requireStrictEmailValidation     Boolean @default(true)
  allowMultipleInvitationsPerEmail Boolean @default(false)
  autoRevokeExpiredAfterDays       Int? // null = disabled
  requirePhoneNumber               Boolean @default(false)

  // Audit Trail
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  createdBy String
  updatedBy String?
  reason    String?  @db.Text // Reason for policy change

  @@unique([businessKey, version])
  @@index([businessKey, isCurrent])
  @@index([validFrom, validTo])
  @@index([funeralHomeId, isCurrent])
  @@map("invitation_management_policies")
}
