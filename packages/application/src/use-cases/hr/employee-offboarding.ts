import { Effect } from 'effect';
import { GoEmployeeTerminationPort, type GoEmployeeTerminationPortService, NetworkError } from '../../ports/go-employee-termination-port';

/**
 * Use Case 4.2: Employee Offboarding Workflow
 * 
 * **Workflow**:
 * 1. Create termination record with effective date and reason
 * 2. Generate offboarding checklist (equipment return, exit interview, final paycheck, COBRA notice)
 * 3. Track completion status
 * 4. Process final paycheck (accrued PTO payout)
 * 5. Generate completion report
 * 
 * **Business Rules**:
 * - Termination date must be specified
 * - Termination reason must be provided
 * - Exit checklist must be completed before final paycheck
 * - Final paycheck includes accrued PTO payout
 * 
 * **Error Cases**:
 * - NetworkError: Go backend communication failure
 * 
 * @see docs/Implement 35 Critical Use Cases with Verified Go Backend Ports.md - Phase 5, Use Case 4.2
 */

export interface EmployeeOffboardingCommand {
  readonly employeeId: string;
  readonly terminationDate: Date;
  readonly reason: string;
  readonly processFinalPay: boolean; // Whether to process final paycheck immediately
}

export interface EmployeeOffboardingResult {
  readonly terminationId: string;
  readonly employeeId: string;
  readonly terminationDate: Date;
  readonly reason: string;
  readonly tasksTotal: number;
  readonly tasksCompleted: number;
  readonly tasksRemaining: number;
  readonly finalPayProcessed: boolean;
  readonly status: 'in_progress' | 'completed';
  readonly exitChecklist: ReadonlyArray<{
    readonly id: string;
    readonly name: string;
    readonly completed: boolean;
  }>;
}

export const processEmployeeOffboarding = (
  command: EmployeeOffboardingCommand
) =>
  Effect.gen(function* () {
    const terminationPort = yield* GoEmployeeTerminationPort;

    // Step 1: Create termination record
    yield* terminationPort.terminateEmployee(
      command.employeeId,
      command.terminationDate,
      command.reason
    );

    // Step 2: Get exit checklist (auto-generated by backend)
    const exitChecklist = yield* terminationPort.getExitChecklist(command.employeeId);

    // Step 3: Calculate completion status
    const tasksCompleted = exitChecklist.filter(item => item.completed).length;
    const tasksRemaining = exitChecklist.length - tasksCompleted;
    const allTasksComplete = tasksRemaining === 0;

    // Step 4: Process final paycheck if requested and all tasks are complete
    let finalPayProcessed = false;
    if (command.processFinalPay && allTasksComplete) {
      yield* terminationPort.processFinalPaycheck(command.employeeId);
      finalPayProcessed = true;
    }

    // Step 5: Determine overall status
    const status = allTasksComplete && finalPayProcessed ? 'completed' : 'in_progress';

    return {
      terminationId: command.employeeId, // Use employee ID as termination ID
      employeeId: command.employeeId,
      terminationDate: command.terminationDate,
      reason: command.reason,
      tasksTotal: exitChecklist.length,
      tasksCompleted,
      tasksRemaining,
      finalPayProcessed,
      status,
      exitChecklist: exitChecklist.map(item => ({
        id: item.id,
        name: item.name,
        completed: item.completed,
      })),
    };
  }).pipe(
    Effect.withSpan('processEmployeeOffboarding', {
      attributes: {
        employeeId: command.employeeId,
        terminationDate: command.terminationDate.toISOString(),
        reason: command.reason,
        processFinalPay: command.processFinalPay,
      },
    })
  );

/**
 * Type helper for the Effect return
 */
export type EmployeeOffboardingEffect = Effect.Effect<
  EmployeeOffboardingResult,
  NetworkError,
  GoEmployeeTerminationPortService
>;
