import { describe, it, expect, beforeEach } from 'vitest';
import { Effect } from 'effect';
import { suggestMeetingTimes, type SuggestMeetingTimesCommand } from '../suggest-meeting-times';
import { type CalendarSyncServicePort, type AvailabilitySlot } from '../../../ports/calendar-sync-port';
import { type EmailCalendarSyncPolicyRepositoryService } from '../../../ports/email-calendar-sync-policy-repository';
import { type EmailCalendarSyncPolicy } from '../../../../domain/src/entities/email-sync/email-calendar-sync-policy';

const createMockPolicy = (overrides?: Partial<EmailCalendarSyncPolicy>): EmailCalendarSyncPolicy => ({\n  id: 'policy-1',\n  funeralHomeId: 'home-1',\n  policyName: 'Standard',\n  emailSyncFrequencyMinutes: 15,\n  maxRetries: 3,\n  retryDelaySeconds: 5,\n  emailMatchingStrategy: 'exact_with_fallback',\n  fuzzyMatchThreshold: 85,\n  emailFallbackStrategies: ['exact', 'domain'],\n  calendarFieldMappings: {\n    subject: true,\n    startTime: true,\n    endTime: true,\n    attendees: true,\n    description: true,\n    location: true,\n  },\n  timezoneHandling: 'local',\n  calendarSyncRetryPolicy: 'exponential',\n  availabilityLookAheadDays: 30,\n  blockOutTimePerEventMinutes: 15,\n  meetingDurationMinutes: 60, // Default 1 hour\n  timeSlotSuggestionCount: 5, // Return up to 5 suggestions\n  minimumBufferMinutes: 15, // 15 min buffer between suggestions\n  workingHoursStartTime: '09:00',\n  workingHoursEndTime: '17:00',\n  notificationDelayMinutes: 5,\n  enableSyncNotifications: true,\n  version: 1,\n  validFrom: new Date(),\n  validTo: null,\n  isActive: true,\n  createdAt: new Date(),\n  updatedAt: new Date(),\n  ...overrides,\n});\n\ndescribe('Suggest Meeting Times - Policy-Driven', () => {\n  let mockCalendarSync: CalendarSyncServicePort;\n  let mockPolicyRepo: EmailCalendarSyncPolicyRepositoryService;\n\n  beforeEach(() => {\n    mockCalendarSync = {\n      createEvent: () => Effect.succeed({ externalId: '', calendarEvent: {} as any }),\n      updateEvent: () => Effect.succeed(void 0),\n      deleteEvent: () => Effect.succeed(void 0),\n      getEvent: () => Effect.succeed(null),\n      listEvents: () => Effect.succeed([]),\n      getAvailability: () => Effect.succeed([]),\n      refreshToken: () => Effect.succeed(void 0),\n    };\n\n    mockPolicyRepo = {\n      findByFuneralHome: () => Effect.succeed(createMockPolicy()),\n      findById: () => Effect.succeed(createMockPolicy()),\n      create: () => Effect.succeed(createMockPolicy()),\n      update: () => Effect.succeed(createMockPolicy()),\n      delete: () => Effect.succeed(void 0),\n    };\n  });\n\n  describe('Single Attendee - Standard Policy', () => {\n    it('should suggest available time slots for single attendee', async () => {\n      mockCalendarSync.getAvailability = () =>\n        Effect.succeed([\n          {\n            startTime: new Date('2025-12-01T09:00:00Z'),\n            endTime: new Date('2025-12-01T17:00:00Z'),\n            status: 'free',\n          },\n        ]);\n\n      const policy = createMockPolicy({\n        meetingDurationMinutes: 60,\n        timeSlotSuggestionCount: 5,\n        minimumBufferMinutes: 15,\n      });\n      mockPolicyRepo.findByFuneralHome = () => Effect.succeed(policy);\n\n      const command: SuggestMeetingTimesCommand = {\n        attendeeUserIds: ['user-1'],\n        provider: 'microsoft',\n        startDate: new Date('2025-12-01T09:00:00Z'),\n        endDate: new Date('2025-12-01T17:00:00Z'),\n        funeralHomeId: 'home-1',\n      };\n\n      const result = await Effect.runPromise(\n        Effect.provide(\n          suggestMeetingTimes(command),\n          Effect.mergeContexts(\n            Effect.contextFromEnvironment(() => mockCalendarSync),\n            Effect.contextFromEnvironment(() => mockPolicyRepo)\n          )\n        )\n      );\n\n      // Should suggest multiple 1-hour slots with 15-min buffer\n      expect(result.length).toBeGreaterThan(0);\n      expect(result.length).toBeLessThanOrEqual(5); // Policy limit\n      expect(result[0]?.startTime.getUTCHours()).toBe(9);\n      expect(result[0]?.endTime.getUTCHours()).toBe(10);\n    });\n\n    it('should respect policy meeting duration (60 min)', async () => {\n      mockCalendarSync.getAvailability = () =>\n        Effect.succeed([\n          {\n            startTime: new Date('2025-12-01T09:00:00Z'),\n            endTime: new Date('2025-12-01T12:00:00Z'),\n            status: 'free',\n          },\n        ]);\n\n      mockPolicyRepo.findByFuneralHome = () => Effect.succeed(createMockPolicy());\n\n      const command: SuggestMeetingTimesCommand = {\n        attendeeUserIds: ['user-1'],\n        provider: 'microsoft',\n        startDate: new Date('2025-12-01T09:00:00Z'),\n        endDate: new Date('2025-12-01T12:00:00Z'),\n        funeralHomeId: 'home-1',\n      };\n\n      const result = await Effect.runPromise(\n        Effect.provide(\n          suggestMeetingTimes(command),\n          Effect.mergeContexts(\n            Effect.contextFromEnvironment(() => mockCalendarSync),\n            Effect.contextFromEnvironment(() => mockPolicyRepo)\n          )\n        )\n      );\n\n      // All suggestions should be 60 minutes long\n      for (const slot of result) {\n        expect(slot.endTime.getTime() - slot.startTime.getTime()).toBe(60 * 60 * 1000);\n      }\n    });\n  });\n\n  describe('Multi-Attendee Intersection - Standard Policy', () => {\n    it('should find common free time for multiple attendees', async () => {\n      const user1Availability: AvailabilitySlot[] = [\n        {\n          startTime: new Date('2025-12-01T09:00:00Z'),\n          endTime: new Date('2025-12-01T12:00:00Z'),\n          status: 'free',\n        },\n        {\n          startTime: new Date('2025-12-01T14:00:00Z'),\n          endTime: new Date('2025-12-01T17:00:00Z'),\n          status: 'free',\n        },\n      ];\n\n      const user2Availability: AvailabilitySlot[] = [\n        {\n          startTime: new Date('2025-12-01T10:00:00Z'),\n          endTime: new Date('2025-12-01T15:00:00Z'),\n          status: 'free',\n        },\n      ];\n\n      let callCount = 0;\n      mockCalendarSync.getAvailability = () => {\n        const result = callCount === 0 ? user1Availability : user2Availability;\n        callCount++;\n        return Effect.succeed(result);\n      };\n\n      mockPolicyRepo.findByFuneralHome = () => Effect.succeed(createMockPolicy());\n\n      const command: SuggestMeetingTimesCommand = {\n        attendeeUserIds: ['user-1', 'user-2'],\n        provider: 'microsoft',\n        startDate: new Date('2025-12-01T09:00:00Z'),\n        endDate: new Date('2025-12-01T17:00:00Z'),\n        funeralHomeId: 'home-1',\n      };\n\n      const result = await Effect.runPromise(\n        Effect.provide(\n          suggestMeetingTimes(command),\n          Effect.mergeContexts(\n            Effect.contextFromEnvironment(() => mockCalendarSync),\n            Effect.contextFromEnvironment(() => mockPolicyRepo)\n          )\n        )\n      );\n\n      // Should suggest times only when both are free (10:00-12:00 and 14:00-15:00 overlap)\n      expect(result.length).toBeGreaterThan(0);\n      // First suggestion should be 10:00-11:00 (common free time)\n      expect(result[0]?.startTime.getUTCHours()).toBe(10);\n    });\n\n    it('should return empty when attendees have no common availability', async () => {\n      const user1Availability: AvailabilitySlot[] = [\n        {\n          startTime: new Date('2025-12-01T09:00:00Z'),\n          endTime: new Date('2025-12-01T11:00:00Z'),\n          status: 'free',\n        },\n      ];\n\n      const user2Availability: AvailabilitySlot[] = [\n        {\n          startTime: new Date('2025-12-01T13:00:00Z'),\n          endTime: new Date('2025-12-01T15:00:00Z'),\n          status: 'free',\n        },\n      ];\n\n      let callCount = 0;\n      mockCalendarSync.getAvailability = () => {\n        const result = callCount === 0 ? user1Availability : user2Availability;\n        callCount++;\n        return Effect.succeed(result);\n      };\n\n      mockPolicyRepo.findByFuneralHome = () => Effect.succeed(createMockPolicy());\n\n      const command: SuggestMeetingTimesCommand = {\n        attendeeUserIds: ['user-1', 'user-2'],\n        provider: 'microsoft',\n        startDate: new Date('2025-12-01T09:00:00Z'),\n        endDate: new Date('2025-12-01T17:00:00Z'),\n        funeralHomeId: 'home-1',\n      };\n\n      const result = await Effect.runPromise(\n        Effect.provide(\n          suggestMeetingTimes(command),\n          Effect.mergeContexts(\n            Effect.contextFromEnvironment(() => mockCalendarSync),\n            Effect.contextFromEnvironment(() => mockPolicyRepo)\n          )\n        )\n      );\n\n      expect(result.length).toBe(0);\n    });\n  });\n\n  describe('Duration Override', () => {\n    it('should use command duration over policy default', async () => {\n      mockCalendarSync.getAvailability = () =>\n        Effect.succeed([\n          {\n            startTime: new Date('2025-12-01T09:00:00Z'),\n            endTime: new Date('2025-12-01T12:00:00Z'),\n            status: 'free',\n          },\n        ]);\n\n      const policy = createMockPolicy({ meetingDurationMinutes: 60 });\n      mockPolicyRepo.findByFuneralHome = () => Effect.succeed(policy);\n\n      const command: SuggestMeetingTimesCommand = {\n        attendeeUserIds: ['user-1'],\n        provider: 'microsoft',\n        durationMinutes: 30, // Override to 30 min\n        startDate: new Date('2025-12-01T09:00:00Z'),\n        endDate: new Date('2025-12-01T12:00:00Z'),\n        funeralHomeId: 'home-1',\n      };\n\n      const result = await Effect.runPromise(\n        Effect.provide(\n          suggestMeetingTimes(command),\n          Effect.mergeContexts(\n            Effect.contextFromEnvironment(() => mockCalendarSync),\n            Effect.contextFromEnvironment(() => mockPolicyRepo)\n          )\n        )\n      );\n\n      // Should suggest 30-minute slots, allowing more suggestions\n      expect(result.length).toBeGreaterThan(0);\n      for (const slot of result) {\n        expect(slot.endTime.getTime() - slot.startTime.getTime()).toBe(30 * 60 * 1000);\n      }\n    });\n  });\n\n  describe('Suggestion Count - Policy Limits', () => {\n    it('should respect timeSlotSuggestionCount from policy - Standard (5)', async () => {\n      mockCalendarSync.getAvailability = () =>\n        Effect.succeed([\n          {\n            startTime: new Date('2025-12-01T09:00:00Z'),\n            endTime: new Date('2025-12-01T17:00:00Z'),\n            status: 'free',\n          },\n        ]);\n\n      const policy = createMockPolicy({\n        meetingDurationMinutes: 30,\n        timeSlotSuggestionCount: 5,\n        minimumBufferMinutes: 15,\n      });\n      mockPolicyRepo.findByFuneralHome = () => Effect.succeed(policy);\n\n      const command: SuggestMeetingTimesCommand = {\n        attendeeUserIds: ['user-1'],\n        provider: 'microsoft',\n        startDate: new Date('2025-12-01T09:00:00Z'),\n        endDate: new Date('2025-12-01T17:00:00Z'),\n        funeralHomeId: 'home-1',\n      };\n\n      const result = await Effect.runPromise(\n        Effect.provide(\n          suggestMeetingTimes(command),\n          Effect.mergeContexts(\n            Effect.contextFromEnvironment(() => mockCalendarSync),\n            Effect.contextFromEnvironment(() => mockPolicyRepo)\n          )\n        )\n      );\n\n      expect(result.length).toBeLessThanOrEqual(5);\n    });\n\n    it('should limit to 3 suggestions with Strict policy', async () => {\n      mockCalendarSync.getAvailability = () =>\n        Effect.succeed([\n          {\n            startTime: new Date('2025-12-01T09:00:00Z'),\n            endTime: new Date('2025-12-01T17:00:00Z'),\n            status: 'free',\n          },\n        ]);\n\n      const policy = createMockPolicy({\n        policyName: 'Strict',\n        meetingDurationMinutes: 30,\n        timeSlotSuggestionCount: 3, // Strict: only 3 suggestions\n        minimumBufferMinutes: 15,\n      });\n      mockPolicyRepo.findByFuneralHome = () => Effect.succeed(policy);\n\n      const command: SuggestMeetingTimesCommand = {\n        attendeeUserIds: ['user-1'],\n        provider: 'microsoft',\n        startDate: new Date('2025-12-01T09:00:00Z'),\n        endDate: new Date('2025-12-01T17:00:00Z'),\n        funeralHomeId: 'home-1',\n      };\n\n      const result = await Effect.runPromise(\n        Effect.provide(\n          suggestMeetingTimes(command),\n          Effect.mergeContexts(\n            Effect.contextFromEnvironment(() => mockCalendarSync),\n            Effect.contextFromEnvironment(() => mockPolicyRepo)\n          )\n        )\n      );\n\n      expect(result.length).toBeLessThanOrEqual(3);\n    });\n  });\n\n  describe('Buffer Between Suggestions', () => {\n    it('should respect minimumBufferMinutes between suggestions - Standard (15 min)', async () => {\n      mockCalendarSync.getAvailability = () =>\n        Effect.succeed([\n          {\n            startTime: new Date('2025-12-01T09:00:00Z'),\n            endTime: new Date('2025-12-01T12:00:00Z'),\n            status: 'free',\n          },\n        ]);\n\n      const policy = createMockPolicy({\n        meetingDurationMinutes: 30,\n        minimumBufferMinutes: 15,\n      });\n      mockPolicyRepo.findByFuneralHome = () => Effect.succeed(policy);\n\n      const command: SuggestMeetingTimesCommand = {\n        attendeeUserIds: ['user-1'],\n        provider: 'microsoft',\n        startDate: new Date('2025-12-01T09:00:00Z'),\n        endDate: new Date('2025-12-01T12:00:00Z'),\n        funeralHomeId: 'home-1',\n      };\n\n      const result = await Effect.runPromise(\n        Effect.provide(\n          suggestMeetingTimes(command),\n          Effect.mergeContexts(\n            Effect.contextFromEnvironment(() => mockCalendarSync),\n            Effect.contextFromEnvironment(() => mockPolicyRepo)\n          )\n        )\n      );\n\n      // Check buffer between consecutive suggestions\n      for (let i = 1; i < result.length; i++) {\n        const gapMs = result[i]!.startTime.getTime() - result[i - 1]!.endTime.getTime();\n        const gapMinutes = gapMs / (60 * 1000);\n        expect(gapMinutes).toBeGreaterThanOrEqual(15); // At least 15 min buffer\n      }\n    });\n\n    it('should allow tighter packing with Permissive policy (5 min buffer)', async () => {\n      mockCalendarSync.getAvailability = () =>\n        Effect.succeed([\n          {\n            startTime: new Date('2025-12-01T09:00:00Z'),\n            endTime: new Date('2025-12-01T12:00:00Z'),\n            status: 'free',\n          },\n        ]);\n\n      const policy = createMockPolicy({\n        policyName: 'Permissive',\n        meetingDurationMinutes: 30,\n        minimumBufferMinutes: 5, // Tight packing\n      });\n      mockPolicyRepo.findByFuneralHome = () => Effect.succeed(policy);\n\n      const command: SuggestMeetingTimesCommand = {\n        attendeeUserIds: ['user-1'],\n        provider: 'microsoft',\n        startDate: new Date('2025-12-01T09:00:00Z'),\n        endDate: new Date('2025-12-01T12:00:00Z'),\n        funeralHomeId: 'home-1',\n      };\n\n      const result = await Effect.runPromise(\n        Effect.provide(\n          suggestMeetingTimes(command),\n          Effect.mergeContexts(\n            Effect.contextFromEnvironment(() => mockCalendarSync),\n            Effect.contextFromEnvironment(() => mockPolicyRepo)\n          )\n        )\n      );\n\n      // Permissive should allow more suggestions due to smaller buffer\n      expect(result.length).toBeGreaterThan(0);\n    });\n  });\n\n  describe('Confidence Scoring - Mid-Day Preference', () => {\n    it('should rank mid-day slots higher than early/late slots', async () => {\n      mockCalendarSync.getAvailability = () =>\n        Effect.succeed([\n          {\n            startTime: new Date('2025-12-01T09:00:00Z'),\n            endTime: new Date('2025-12-01T17:00:00Z'),\n            status: 'free',\n          },\n        ]);\n\n      const policy = createMockPolicy({\n        meetingDurationMinutes: 60,\n        timeSlotSuggestionCount: 5,\n        minimumBufferMinutes: 0, // No buffer for testing\n        workingHoursStartTime: '09:00',\n        workingHoursEndTime: '17:00',\n      });\n      mockPolicyRepo.findByFuneralHome = () => Effect.succeed(policy);\n\n      const command: SuggestMeetingTimesCommand = {\n        attendeeUserIds: ['user-1'],\n        provider: 'microsoft',\n        startDate: new Date('2025-12-01T09:00:00Z'),\n        endDate: new Date('2025-12-01T17:00:00Z'),\n        funeralHomeId: 'home-1',\n      };\n\n      const result = await Effect.runPromise(\n        Effect.provide(\n          suggestMeetingTimes(command),\n          Effect.mergeContexts(\n            Effect.contextFromEnvironment(() => mockCalendarSync),\n            Effect.contextFromEnvironment(() => mockPolicyRepo)\n          )\n        )\n      );\n\n      // First suggestion should be mid-day (around 13:00/1pm)\n      expect(result[0]?.startTime.getUTCHours()).toBeGreaterThan(9);\n      expect(result[0]?.startTime.getUTCHours()).toBeLessThan(17);\n      // Confidence should decrease for early suggestions\n      expect(result[0]?.confidence).toBeGreaterThanOrEqual(50);\n    });\n  });\n\n  describe('Multi-Provider Support', () => {\n    it('should work with Microsoft provider', async () => {\n      mockCalendarSync.getAvailability = () =>\n        Effect.succeed([\n          {\n            startTime: new Date('2025-12-01T09:00:00Z'),\n            endTime: new Date('2025-12-01T17:00:00Z'),\n            status: 'free',\n          },\n        ]);\n\n      mockPolicyRepo.findByFuneralHome = () => Effect.succeed(createMockPolicy());\n\n      const command: SuggestMeetingTimesCommand = {\n        attendeeUserIds: ['user-1'],\n        provider: 'microsoft',\n        startDate: new Date('2025-12-01T09:00:00Z'),\n        endDate: new Date('2025-12-01T17:00:00Z'),\n        funeralHomeId: 'home-1',\n      };\n\n      const result = await Effect.runPromise(\n        Effect.provide(\n          suggestMeetingTimes(command),\n          Effect.mergeContexts(\n            Effect.contextFromEnvironment(() => mockCalendarSync),\n            Effect.contextFromEnvironment(() => mockPolicyRepo)\n          )\n        )\n      );\n\n      expect(result).toEqual(expect.any(Array));\n    });\n\n    it('should work with Google provider', async () => {\n      mockCalendarSync.getAvailability = () =>\n        Effect.succeed([\n          {\n            startTime: new Date('2025-12-01T09:00:00Z'),\n            endTime: new Date('2025-12-01T17:00:00Z'),\n            status: 'free',\n          },\n        ]);\n\n      mockPolicyRepo.findByFuneralHome = () => Effect.succeed(createMockPolicy());\n\n      const command: SuggestMeetingTimesCommand = {\n        attendeeUserIds: ['user-1'],\n        provider: 'google',\n        startDate: new Date('2025-12-01T09:00:00Z'),\n        endDate: new Date('2025-12-01T17:00:00Z'),\n        funeralHomeId: 'home-1',\n      };\n\n      const result = await Effect.runPromise(\n        Effect.provide(\n          suggestMeetingTimes(command),\n          Effect.mergeContexts(\n            Effect.contextFromEnvironment(() => mockCalendarSync),\n            Effect.contextFromEnvironment(() => mockPolicyRepo)\n          )\n        )\n      );\n\n      expect(result).toEqual(expect.any(Array));\n    });\n  });\n});\n