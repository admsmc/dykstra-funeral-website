import { Effect } from 'effect';
import { ValidationError } from '@dykstra/domain';
import type { GoInventoryPortService } from '../../ports/go-inventory-port';
import { GoInventoryPort, NetworkError } from '../../ports/go-inventory-port';

/**
 * Use Case 7.3: Inventory Valuation Report
 * 
 * Generates comprehensive inventory valuation reports showing total inventory
 * value using weighted average cost (WAC) method. Used for financial reporting,
 * balance sheet preparation, and inventory analysis.
 * 
 * Business Logic:
 * - Aggregates all inventory items across locations
 * - Calculates total value using WAC per item
 * - Groups by category for analysis
 * - Provides location-level breakdowns
 * - Supports filtering by location and category
 * 
 * Typical Use: Monthly/quarterly financial reporting, audit preparation
 */

/**
 * Inventory Valuation Report
 *
 * Policy Type: Type B
 * Refactoring Status: ðŸ”´ HARDCODED
 * Policy Entity: N/A
 * Persisted In: N/A
 * Go Backend: YES
 * Per-Funeral-Home: YES
 * Test Coverage: 0 tests
 * Last Updated: N/A
 */

export interface GenerateInventoryValuationReportCommand {
  /** Report date (defaults to current date) */
  asOfDate?: Date;
  
  /** Optional: Filter by location */
  locationId?: string;
  
  /** Optional: Filter by item category */
  category?: string;
  
  /** User generating the report */
  generatedBy: string;
  
  /** Include zero-balance items */
  includeZeroBalance?: boolean;
}

export interface InventoryItemValuation {
  /** Item details */
  itemId: string;
  itemName: string;
  itemSku: string;
  category: string;
  
  /** Location details */
  locationId: string;
  locationName: string;
  
  /** Quantities */
  quantityOnHand: number;
  quantityAvailable: number;
  quantityReserved: number;
  
  /** Valuation */
  unitCost: number;
  totalValue: number;
}

export interface CategoryValuation {
  category: string;
  itemCount: number;
  totalQuantity: number;
  totalValue: number;
  averageCostPerItem: number;
}

export interface LocationValuation {
  locationId: string;
  locationName: string;
  itemCount: number;
  totalQuantity: number;
  totalValue: number;
}

export interface GenerateInventoryValuationReportResult {
  /** Report metadata */
  metadata: {
    asOfDate: Date;
    generatedAt: Date;
    generatedBy: string;
    locationFilter?: string;
    categoryFilter?: string;
  };
  
  /** Individual item valuations */
  items: InventoryItemValuation[];
  
  /** Category summaries */
  categories: CategoryValuation[];
  
  /** Location summaries */
  locations: LocationValuation[];
  
  /** Overall totals */
  totals: {
    totalItems: number;
    totalQuantity: number;
    totalValue: number;
    averageValuePerItem: number;
  };
}

function validateCommand(
  command: GenerateInventoryValuationReportCommand
): Effect.Effect<void, ValidationError> {
  return Effect.gen(function* () {
    const errors: string[] = [];
    
    if (!command.generatedBy || command.generatedBy.trim() === '') {
      errors.push('Generated by user is required');
    }
    
    if (command.asOfDate && command.asOfDate > new Date()) {
      errors.push('As-of date cannot be in the future');
    }
    
    if (errors.length > 0) {
      return yield* Effect.fail(new ValidationError({ message: errors.join('; ') }));
    }
  });
}

export function generateInventoryValuationReport(
  command: GenerateInventoryValuationReportCommand
): Effect.Effect<
  GenerateInventoryValuationReportResult,
  ValidationError | NetworkError,
  GoInventoryPortService
> {
  return Effect.gen(function* () {
    // Step 1: Validate command
    yield* validateCommand(command);
    
    const inventoryPort = yield* GoInventoryPort;
    const asOfDate = command.asOfDate || new Date();
    const includeZeroBalance = command.includeZeroBalance ?? false;
    
    // Step 2: Get all inventory items
    const allItems = yield* inventoryPort.listItems({
      category: command.category,
      status: 'active',
    });
    
    // Step 3: Get balances for each item at each location
    const itemValuations: InventoryItemValuation[] = [];
    
    for (const item of allItems) {
      // Get balance for this item (optionally filtered by location)
      const balance = yield* inventoryPort.getBalance(
        item.id,
        command.locationId || 'DEFAULT'
      );
      
      // Skip zero-balance items if not included
      if (!includeZeroBalance && balance.quantityOnHand === 0) {
        continue;
      }
      
      itemValuations.push({
        itemId: item.id,
        itemName: (item as any).name || item.id,
        itemSku: (item as any).sku || item.id,
        category: (item as any).category || 'Uncategorized',
        locationId: (balance as any).locationId || 'Unknown',
        locationName: (balance as any).locationName || 'Unknown',
        quantityOnHand: balance.quantityOnHand,
        quantityAvailable: (balance as any).quantityAvailable || 0,
        quantityReserved: (balance as any).quantityReserved || 0,
        unitCost: (balance as any).unitCost || 0,
        totalValue: (balance as any).totalValue || 0,
      });
    }
    
    // Step 4: Aggregate by category
    const categoryMap = new Map<string, {
      category: string;
      itemCount: number;
      totalQuantity: number;
      totalValue: number;
    }>();
    
    for (const item of itemValuations) {
      const existing = categoryMap.get(item.category);
      if (existing) {
        existing.itemCount += 1;
        existing.totalQuantity += item.quantityOnHand;
        existing.totalValue += item.totalValue;
      } else {
        categoryMap.set(item.category, {
          category: item.category,
          itemCount: 1,
          totalQuantity: item.quantityOnHand,
          totalValue: item.totalValue,
        });
      }
    }
    
    const categories: CategoryValuation[] = Array.from(categoryMap.values())
      .map(cat => ({
        ...cat,
        averageCostPerItem: cat.itemCount > 0 ? cat.totalValue / cat.itemCount : 0,
      }))
      .sort((a, b) => b.totalValue - a.totalValue); // Sort by value descending
    
    // Step 5: Aggregate by location
    const locationMap = new Map<string, {
      locationId: string;
      locationName: string;
      itemCount: number;
      totalQuantity: number;
      totalValue: number;
    }>();
    
    for (const item of itemValuations) {
      const existing = locationMap.get(item.locationId);
      if (existing) {
        existing.itemCount += 1;
        existing.totalQuantity += item.quantityOnHand;
        existing.totalValue += item.totalValue;
      } else {
        locationMap.set(item.locationId, {
          locationId: item.locationId,
          locationName: item.locationName,
          itemCount: 1,
          totalQuantity: item.quantityOnHand,
          totalValue: item.totalValue,
        });
      }
    }
    
    const locations = Array.from(locationMap.values())
      .sort((a, b) => b.totalValue - a.totalValue);
    
    // Step 6: Calculate overall totals
    const totalValue = itemValuations.reduce((sum, item) => sum + item.totalValue, 0);
    const totalQuantity = itemValuations.reduce((sum, item) => sum + item.quantityOnHand, 0);
    const totalItems = itemValuations.length;
    
    return {
      metadata: {
        asOfDate,
        generatedAt: new Date(),
        generatedBy: command.generatedBy,
        locationFilter: command.locationId,
        categoryFilter: command.category,
      },
      items: itemValuations,
      categories,
      locations,
      totals: {
        totalItems,
        totalQuantity,
        totalValue,
        averageValuePerItem: totalItems > 0 ? totalValue / totalItems : 0,
      },
    };
  });
}
