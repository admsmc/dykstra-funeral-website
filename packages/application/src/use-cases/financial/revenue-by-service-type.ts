import { Effect } from 'effect';
import { ValidationError } from '@dykstra/domain';
import {
  GoFinancialPort,
  type GoFinancialPortService,
  type NetworkError,
} from '../../ports/go-financial-port';

/**
 * Revenue by Service Type Report
 * 
 * Generates revenue analysis reports grouped by service type (Traditional Funeral,
 * Cremation, Memorial Service, etc.). Used for business intelligence, service mix
 * analysis, and strategic planning.
 * 
 * Business Logic:
 * - Aggregates revenue by service type from journal entries
 * - Supports date range filtering
 * - Calculates percentage of total revenue per service type
 * - Identifies trending services
 * - Provides average revenue per service
 * 
 * Typical Use: Monthly/quarterly business reviews, pricing strategy analysis
 */

/**
 * Revenue By Service Type
 *
 * Policy Type: Type B
 * Refactoring Status: ðŸ”´ HARDCODED
 * Policy Entity: N/A
 * Persisted In: N/A
 * Go Backend: YES
 * Per-Funeral-Home: YES
 * Test Coverage: 0 tests
 * Last Updated: N/A
 */

export interface GenerateRevenueByServiceTypeCommand {
  /** Start date of reporting period */
  startDate: Date;
  
  /** End date of reporting period */
  endDate: Date;
  
  /** User generating the report */
  generatedBy: string;
  
  /** Optional: Filter by specific service type */
  serviceType?: string;
}

export interface ServiceTypeRevenue {
  serviceType: string;
  serviceCount: number;
  totalRevenue: number;
  averageRevenue: number;
  percentageOfTotal: number;
}

export interface GenerateRevenueByServiceTypeResult {
  /** Report metadata */
  metadata: {
    period: {
      startDate: Date;
      endDate: Date;
    };
    generatedAt: Date;
    generatedBy: string;
  };
  
  /** Revenue by service type */
  serviceTypes: ServiceTypeRevenue[];
  
  /** Overall totals */
  totals: {
    totalServices: number;
    totalRevenue: number;
    averageRevenuePerService: number;
  };
}

function validateCommand(
  command: GenerateRevenueByServiceTypeCommand
): Effect.Effect<void, ValidationError> {
  return Effect.gen(function* () {
    const errors: string[] = [];
    
    if (!command.startDate) {
      errors.push('Start date is required');
    }
    
    if (!command.endDate) {
      errors.push('End date is required');
    }
    
    if (command.startDate && command.endDate && command.startDate > command.endDate) {
      errors.push('Start date must be before or equal to end date');
    }
    
    // Reasonable date range limit
    if (command.startDate && command.endDate) {
      const daysDiff = Math.floor(
        (command.endDate.getTime() - command.startDate.getTime()) / (1000 * 60 * 60 * 24)
      );
      if (daysDiff > 730) { // 2 years
        errors.push('Date range cannot exceed 2 years');
      }
    }
    
    if (!command.generatedBy || command.generatedBy.trim() === '') {
      errors.push('Generated by user is required');
    }
    
    if (errors.length > 0) {
      return yield* Effect.fail(new ValidationError({ message: errors.join('; ') }));
    }
  });
}

export function generateRevenueByServiceType(
  command: GenerateRevenueByServiceTypeCommand
): Effect.Effect<
  GenerateRevenueByServiceTypeResult,
  ValidationError | NetworkError,
  GoFinancialPortService
> {
  return Effect.gen(function* () {
    // Step 1: Validate command
    yield* validateCommand(command);
    
    const financialPort = yield* GoFinancialPort;
    
    // Step 2: Fetch journal entries for revenue accounts (4000-4999)
    // In production, this would use specific revenue account ranges
    const journalEntries = yield* financialPort.listJournalEntries({
      startDate: command.startDate,
      endDate: command.endDate,
      status: 'posted', // Only posted entries
    });
    
    // Step 3: Aggregate revenue by service type
    // Note: In production, service type would come from case/contract metadata
    // linked to the journal entry. For this implementation, we'll extract from
    // the description or reference field.
    const revenueMap = new Map<string, {
      serviceType: string;
      serviceCount: number;
      totalRevenue: number;
    }>();
    
    for (const entry of journalEntries) {
      // Extract service type from entry description
      // Simplified: look for keywords in description
      const serviceType = extractServiceType(entry.description || 'Unknown');
      
      // Skip if filtering and doesn't match
      if (command.serviceType && serviceType !== command.serviceType) {
        continue;
      }
      
      // Calculate revenue (credit amounts for revenue accounts)
      const revenue = entry.lines
        .filter((li: typeof entry.lines[number]) => li.accountNumber.startsWith('4')) // Revenue accounts
        .reduce((sum: number, li: typeof entry.lines[number]) => sum + li.credit, 0);
      
      const existing = revenueMap.get(serviceType);
      if (existing) {
        existing.serviceCount += 1;
        existing.totalRevenue += revenue;
      } else {
        revenueMap.set(serviceType, {
          serviceType,
          serviceCount: 1,
          totalRevenue: revenue,
        });
      }
    }
    
    // Step 4: Calculate percentages and averages
    const totalRevenue = Array.from(revenueMap.values()).reduce(
      (sum, item) => sum + item.totalRevenue,
      0
    );
    
    const serviceTypes: ServiceTypeRevenue[] = Array.from(revenueMap.values())
      .map(item => ({
        serviceType: item.serviceType,
        serviceCount: item.serviceCount,
        totalRevenue: item.totalRevenue,
        averageRevenue: item.serviceCount > 0 ? item.totalRevenue / item.serviceCount : 0,
        percentageOfTotal: totalRevenue > 0 ? (item.totalRevenue / totalRevenue) * 100 : 0,
      }))
      .sort((a, b) => b.totalRevenue - a.totalRevenue); // Sort by revenue descending
    
    // Step 5: Calculate overall totals
    const totalServices = serviceTypes.reduce((sum, st) => sum + st.serviceCount, 0);
    
    return {
      metadata: {
        period: {
          startDate: command.startDate,
          endDate: command.endDate,
        },
        generatedAt: new Date(),
        generatedBy: command.generatedBy,
      },
      serviceTypes,
      totals: {
        totalServices,
        totalRevenue,
        averageRevenuePerService: totalServices > 0 ? totalRevenue / totalServices : 0,
      },
    };
  });
}

/**
 * Extract service type from journal entry description
 * In production, this would come from linked case/contract metadata
 */
function extractServiceType(description: string): string {
  const desc = description.toLowerCase();
  
  if (desc.includes('traditional') || desc.includes('burial')) {
    return 'Traditional Funeral';
  }
  if (desc.includes('cremation') || desc.includes('memorial')) {
    return 'Cremation';
  }
  if (desc.includes('graveside')) {
    return 'Graveside Service';
  }
  if (desc.includes('direct') || desc.includes('immediate')) {
    return 'Direct Disposition';
  }
  if (desc.includes('pre-need') || desc.includes('preneed')) {
    return 'Pre-Need';
  }
  
  return 'Other Services';
}
